<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents** _generated with [DocToc](https://github.com/thlorenz/doctoc)_

- [1 章](#1-%E7%AB%A0)
  - [演算指向よりもデータ指向](#%E6%BC%94%E7%AE%97%E6%8C%87%E5%90%91%E3%82%88%E3%82%8A%E3%82%82%E3%83%87%E3%83%BC%E3%82%BF%E6%8C%87%E5%90%91)
  - [ソフトウェアシステムにおける 3 つの重要な課題](#%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B-3-%E3%81%A4%E3%81%AE%E9%87%8D%E8%A6%81%E3%81%AA%E8%AA%B2%E9%A1%8C)
  - [信頼性](#%E4%BF%A1%E9%A0%BC%E6%80%A7)
  - [ハードウェアの障害](#%E3%83%8F%E3%83%BC%E3%83%89%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E9%9A%9C%E5%AE%B3)
  - [ソフトウェアのエラー](#%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC)
  - [ヒューマンエラー](#%E3%83%92%E3%83%A5%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%A8%E3%83%A9%E3%83%BC)
  - [スケーラビリティ](#%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%A9%E3%83%93%E3%83%AA%E3%83%86%E3%82%A3)
  - [負荷の表現](#%E8%B2%A0%E8%8D%B7%E3%81%AE%E8%A1%A8%E7%8F%BE)
  - [パフォーマンスの表現](#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E8%A1%A8%E7%8F%BE)
  - [負荷への対処のアプローチ](#%E8%B2%A0%E8%8D%B7%E3%81%B8%E3%81%AE%E5%AF%BE%E5%87%A6%E3%81%AE%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81)
  - [メンテナンス性](#%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E6%80%A7)
  - [要求](#%E8%A6%81%E6%B1%82)
- [2 章](#2-%E7%AB%A0)
  - [リレーショナルモデルとドキュメントモデル](#%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%A2%E3%83%87%E3%83%AB%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%A2%E3%83%87%E3%83%AB)
  - [多対一と多対多の関係](#%E5%A4%9A%E5%AF%BE%E4%B8%80%E3%81%A8%E5%A4%9A%E5%AF%BE%E5%A4%9A%E3%81%AE%E9%96%A2%E4%BF%82)
  - [ドキュメントデータベースは歴史を繰り返すのか](#%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%AF%E6%AD%B4%E5%8F%B2%E3%82%92%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%99%E3%81%AE%E3%81%8B)
  - [今日のリレーショナルデータベースとドキュメントデータベース](#%E4%BB%8A%E6%97%A5%E3%81%AE%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%A8%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9)
  - [ドキュメント及びリレーショナルデータベースの融合](#%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E5%8F%8A%E3%81%B3%E3%83%AA%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%81%AE%E8%9E%8D%E5%90%88)
  - [データのためのクエリ言語](#%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%AF%E3%82%A8%E3%83%AA%E8%A8%80%E8%AA%9E)
  - [MapReduce でのクエリ](#mapreduce-%E3%81%A7%E3%81%AE%E3%82%AF%E3%82%A8%E3%83%AA)
  - [グラフ型のデータモデル](#%E3%82%B0%E3%83%A9%E3%83%95%E5%9E%8B%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%83%A2%E3%83%87%E3%83%AB)
- [3 章](#3-%E7%AB%A0)
  - [ストレージと抽出](#%E3%82%B9%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B8%E3%81%A8%E6%8A%BD%E5%87%BA)
  - [データベースを駆動するデータ構造](#%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9%E3%82%92%E9%A7%86%E5%8B%95%E3%81%99%E3%82%8B%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0)
  - [BTree と LSMTree の比較](#btree-%E3%81%A8-lsmtree-%E3%81%AE%E6%AF%94%E8%BC%83)
  - [トランザクション処理化、分析処理化？](#%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E5%87%A6%E7%90%86%E5%8C%96%E5%88%86%E6%9E%90%E5%87%A6%E7%90%86%E5%8C%96)
- [4 章](#4-%E7%AB%A0)
  - [エンコーディングと進化](#%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%A8%E9%80%B2%E5%8C%96)
  - [データエンコードのフォーマット](#%E3%83%87%E3%83%BC%E3%82%BF%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88)
  - [データフローの形態](#%E3%83%87%E3%83%BC%E3%82%BF%E3%83%95%E3%83%AD%E3%83%BC%E3%81%AE%E5%BD%A2%E6%85%8B)
- [二部　イントロ](#%E4%BA%8C%E9%83%A8%E3%80%80%E3%82%A4%E3%83%B3%E3%83%88%E3%83%AD)
  - [分散データ](#%E5%88%86%E6%95%A3%E3%83%87%E3%83%BC%E3%82%BF)
- [5 章](#5-%E7%AB%A0)
  - [レプリケーション](#%E3%83%AC%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)
  - [リーダーとフォロワー](#%E3%83%AA%E3%83%BC%E3%83%80%E3%83%BC%E3%81%A8%E3%83%95%E3%82%A9%E3%83%AD%E3%83%AF%E3%83%BC)
  - [レプリケーションラグにまつわる問題](#%E3%83%AC%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%A9%E3%82%B0%E3%81%AB%E3%81%BE%E3%81%A4%E3%82%8F%E3%82%8B%E5%95%8F%E9%A1%8C)
  - [レプリケーションラグが生じると起こりやすい問題と解決策](#%E3%83%AC%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%A9%E3%82%B0%E3%81%8C%E7%94%9F%E3%81%98%E3%82%8B%E3%81%A8%E8%B5%B7%E3%81%93%E3%82%8A%E3%82%84%E3%81%99%E3%81%84%E5%95%8F%E9%A1%8C%E3%81%A8%E8%A7%A3%E6%B1%BA%E7%AD%96)
  - [マルチリーダーレプリケーション](#%E3%83%9E%E3%83%AB%E3%83%81%E3%83%AA%E3%83%BC%E3%83%80%E3%83%BC%E3%83%AC%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)
  - [書き込みの衝突](#%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E3%81%AE%E8%A1%9D%E7%AA%81)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 1 章

## 演算指向よりもデータ指向

高度に発達した CPU や処理能力といったスペックが制約条件にはならない。
データ量や複雑さ、データの変化する速度が大きな問題。
以下のような機能が、今日のアプリケーションでは必要。

- データベース
- キャッシュ
- 検索インデックス
- ストリーム能力
- バッチ処理

## ソフトウェアシステムにおける 3 つの重要な課題

- 信頼性
  - なにか問題があっても正しく動作し続ける
- スケーラビリティ
  - システムの成長に追従できる
- メンテナンス性
  - 時間が経過したシステムに、多くの開発者が生産的に関われる

## 信頼性

- fault

  - 問題を起こしうるもの。
  - 障害のことではない。

- fault tolerant or resilient
  - 耐障害性を持っていること
  - fault を見越して対処できるシステムであること
- すべての fault に耐えられるってことではない。
- ある種の fault に対する体制について議論することが大事。
- fault が障害を引き起こさないような耐障害性の仕組みを設計しよう。

- 意図的に fault を発生させて、耐障害性の仕組みを動作させてテストする。

  - 警告なしにランダムでここのプロセスを kill するとか
  - 多くの致命的なバグはエラー処理が貧弱なことによるものであるため
  - fault が生じたときに正しく対処されるというか悪心を強める
  - Netflix の Chaos Monkey

- fault は耐性を持つようにすることが望ましい
  - セキュリティ問題のように、回避したほうが望ましいものもある

## ハードウェアの障害

- ハードディスクは壊れる
- 冗長性をもたせて回避しよう
  - ディスクの RAID 構成
    - https://www.rescue-center.jp/explanation/raid/type.html
  - サーバー電源二重化
  - など
- 何かが壊れても冗長な代替が、置き換えまでの時間を稼いでくれる
- 扱うデータ量の増加やアプリケーションに求める処理量の増加で大量のマシンを扱う
  - ハードウェアの fault も増加傾向にある
  - ハードウェアの冗長化とソフトウェアの耐障害性を使う
    - マシン全体が失われても耐えられるようなシステムへの移行が進んでいる
    - rolling upgrade
      - ソフトウェアの更新、入れ替えの方法の一つで、稼働中のシステムを完全には停止させずに徐々に新しいものに入れ替えていく方式

## ソフトウェアのエラー

- ソフトウェアの fault はシステム内でのエラーがある
  - 予測が難しい
  - ノード間で相関性がある
  - ハードウェアの fault よりも多くの障害に繋がりやすい
    - ソフトウェアのバグ
    - プロセスの暴走
    - 依存しているサービスの問題
    - カスケード障害
      - 1 つの fault が他のコンポーネントの fault を次々に引き起こしていく
- 手っ取り早い解決策はない
  - 些細なことの積み重ね
    - 徹底したテスト
    - プロセスの分離
    - 計測
    - 挙動分析

## ヒューマンエラー

- 人間には信頼性がない
- サービス障害の一番多い原因はオペレータの設定ミス
- 信頼性を高めるためにすること
  - 正しいことをしやすく、間違ったことをしにくいシステム設計
  - 障害になりやすいところから、間違いを起こしやすい箇所から分離する
  - 徹底的なテスト
  - モニタリング

## スケーラビリティ

負荷の増大に対してシステムが対応できる能力のこと

## 負荷の表現

- 負荷のパラメータ
  - 負荷を表現する数値
  - Twitter
    - ユーザーごとのフォロワーの分布
    - ファンアウトの負荷を決めるので、負荷パラメータになる

## パフォーマンスの表現

- 負荷の増大したときに調査すること

  - 負荷パラメータを増やしながらシステムリソースを一定に保つと、パフォーマンスにどのような影響があるか
  - 負荷パラメータを増やしてパフォーマンスを一定に保つにはリソースをどれほど増やせばいいか

- パフォーマンスを計測しなければ、負荷がわからない
- バッチ処理
  - スループットを見る
    - コンピュータやネットワーク機器が単位時間あたりに処理できるデータ量のこと。あるいは、その数値を使ってデータ処理能力やデータ転送速度を表す。
    - 数値の単位は「bps」「kbps」「Mbps」で 1 秒あたりのデータ量をビット数で表す。
- オンラインシステム

  - レスポンスタイムを見る

- レスポンスタイムを見る
  - 外れ値が出る時がある
    - レスポンスに時間がかかった場所
    - いろいろな要因でそうなる
  - 平均を見る
    - 算術平均
      - n 個の合計値を n で割った数
        - 1+5+6/
    - 平均を見ても、典型的なレスポンスタイムは見れない
      - どれほどのユーザが遅延を日々体験しているのかわからない
  - percentile を見る
    - 平均を見るよりもいい
    - median（中央値）
      - レスポンスタイムを見るのにいい指標
      - リクエストの半分が中央値未満、もう半分が以上と区別できるのが中央値だから
      - 50percentile とも呼ばれる
        - p50
    - 外れ値を見るのは p90,p99,p999(99.9%)がよく使われる
      - テイルレイテンシとも言う
      - これらの percentile に引っかかるユーザーは大量のデータを扱っていることが推測できる
      - つまり重要顧客
      - このユーザでも満足してもらえるユーザ体験を提供することは重要
      - p999 の改善はかなり負担が大きくてメリットが少ない
    - percentile は SLO や SLA に用いられる指標
      - SLA
        - サービス レベル アグリーメント
        - SLA (サービス レベル アグリーメント) は、アップタイム、応答性、責任などの測定可能な指標に関する、プロバイダーとクライアント間の契約です。これらの契約は通常、会社の新しいビジネス チームや法務チームによって作成されていて、お客様に対する約束とその約束を守れなかった場合の結果を表します。通常、この結果には、違約金、サービス クレジット、ライセンス延長が含まれます。
      - SLO
        - サービス レベル目標
        - SLO (サービス レベル目標) とは、アップタイムや応答時間などの特定の指標に関する SLA 内の合意です。したがって、SLA がお客様とお客様の顧客との間の正式な合意であれば、SLO はお客様から当該顧客に対する個々の約束です。SLO は、顧客の期待値を設定して、IT チームと DevOps チームが達成および測定する必要がある目標をチーム メンバーに伝えるためのものです。
      - 例）SLA = レスポンスの中央値が 200 ミリ秒以下で、p99 が 1 秒以下ならサービスは動作中で、99.9%の時間動作していなければならない
    - HOL
    - head-of-line blocking
      - 大きな percentile のレスポンスはキューイングの遅延であることがあって、サーバーが同時に処理できる数は限られている。低速リクエストに引っ張れられて以降のリクエストの処理が待たされてしまう現象のこと。
      - サーバーがうまくさばけても HOL blocking が発生したらクライアントは待たされている。
      - クライアントでレスポンスタイムを計測するのが重要
  - テイルレイテンシの増幅
    - 複数のバックエンドのレスポンスを待っているクライアントがいる
    - どれかひとつでもバックエンドのレスポンスが遅いものがある
    - 結果的にクライアントはそのバックエンドの処理を待たなければいけなくなる

## 負荷への対処のアプローチ

- スケールアウト
  - 水平のスケーリング
  - マシンを分散して負荷を分散
- スケールアップ
  - 垂直のスケーリング
  - マシンスペック上げる
- shared nothing architecture
  - スケールアウトで負荷分散させること
  - ハイエンドマシンは高価
    - だがシステムがシンプルになる
- スケールアウトとスケールアップをミックスするとコストを抑えられる
  - いくつかの強力なマシンをつかって、小さなマシンを大量に使わない
- elastic
  - 負荷の増大を検知して、自動でコンピューティングリソースを追加できるシステム

## メンテナンス性

3 つの設計原理でレガシーとなるソフトウェアを生み出さないようにする

- 運用性
  - システムをスムーズに動作させ続けるために運用チームが扱いやすいようにする
- 単純性
  - 複雑性を取り除き、新しいエンジニアがシステム理解しやすいようにする
    - big ball of mud
      - 複雑さにはまり、メンテナンスコストが増えたアプリケーションのこと
      - 避けたほうがいい
    - 単純にすることは機能を減らすことではない
      - 「偶発的な複雑さ」を取り除くということ
        - ソフトウェアが解決しようとしている問題がもともとは持っておらず、実装からのみ生じている複雑さ
      - 抽象化で「偶発的な複雑さ」を取り除く
- 進化性
  - 要求の変化に応じてシステムを変えられるようにする
  - 拡張性
  - 修正の容易性
  - plasticity
    - 塑性そせい
    - 力を加えて変形させたとき、永久変形を生じる物質の性質のことを指す。

## 要求

アプリケーションが有益であるための様々な要求

- 機能的な要求
  - データの保存、取り出し、検索、処理
- 非機能的な要求
  - セキュリティ
  - 信頼性
  - コンプライアンス
  - スケーラビリティ
  - 互換性
  - メンテナンス性

# 2 章

## リレーショナルモデルとドキュメントモデル

- リレーショナルモデル
  - SQL のデータモデルと同じ
  - リレーション（SQL ではテーブル）とタプル（SQL では行）の集合
- ドキュメントモデル

  - NoSQL Not Only SQL
  - ドキュメント形式のデータを保存できる
    - JSON 形式
    - XML 形式
  - スキーマがない利点

- リレーショナルデータベースはいろいろな形式の非リレーショナルデータベースと組み合わせて使われていく
  - ポリグロットパーシステンス polyglot persistence
    - 複数モデルの永続化

## 多対一と多対多の関係

- 「地域名」のように自由に入力できるデータ保存の際に、
  - 人間にとって意味のある「文字列」として保存する
    - 将来どこかで変更される可能性がある
  - ユニークな値として「ID」で保存する
    - 変更する必要がない
    - ID が指している情報は変えられる
- 複製は極力排除しないといけない
  - 正規化の鍵
  - ID での値管理はこれに有力
- ドキュメントモデルは多対一に適合できない
  - 1 つの地域に大勢が住んでいる、１つの業界に大勢が働いている
  - 結合のサポートが弱い
- リレーショナルは結合が用意
  - ID を関連するテーブルを覗いたり
- ドキュメントモデルに適応したデータベースであっても、後にデータ同士のつながりを持つことが考えられる
  - そうなったら機能しない

## ドキュメントデータベースは歴史を繰り返すのか

- Information Management System (IMS)
  - IBM が作った 70 年代のビジネスデータの処理用の最も一般的なデータベース
  - 階層モデルというデータモデル
    - ドキュメントデータベースと似ている
- 階層モデルの制約
  - 多対多が難しい
  - 一対多
- 階層モデルの制約を解決するために登場したデータモデル
  - ネットワークモデル
    - 次第に廃れた
    - 別名 CODASYL モデル
      - Conferrence on Data System Language
    - 階層モデルを一般化したもの
    - レコードは必ず 1 つ以上親を持つ
    - レコード間のリンクはポインタみたいなやつ
    - あるレコードにアクセスするためにはルートからリンクに沿ってパスをたどる
      - アクセスパス
    - パスがいろいろあるためいろいろなパスをたどる必要がある
      - もとめるデータへのパスが不明
    - データモデルに変更を加えるとアクセスパスがへんこうするため、変更が難しい
  - リレーショナルモデル
    - SQL
    - クエリオプティマイザがいろいろやってくれる
      - クエリの実行順序
      - どのインデックスを使うか判断
      - SQL でどのデータがほしいかを書くだけで、どのように取得するかを毎回考えて決定してくれる
        - データベース管理システム（DBMS）の持つ機能の一つで、外部から投入された問い合わせ（クエリ）群を最も効率よく処理できるような実行計画を立てる機能を「クエリオプティマイザ」あるいは単にオプティマイザという。DBMS が内部に持つ機能で、性能を決定付ける最も重要な機能の一つだが、利用者が明示的に操作や指示、設定などを行うことは（でき）ないため存在が意識されることは少ない。
    - ネットワークモデルとの違いはクエリオプティマイザの存在
      - アプリケーション開発者ではなくて、クエリオプティマイザにいろいろ操作を委譲できる
    - インデックスを貼れば、クエリは自動でインデックスを使う
    - データモデルへの変更がはるかに容易
- リレーショナルデータベースとドキュメントデータベースに「多対一た多対多の関係の表現」で違いはない
  - リレーショナルモデルは「外部キー」
  - ドキュメントモデルは「ドキュメント参照」
- ドキュメントデータベースは CODASYL を繰り返してない

## 今日のリレーショナルデータベースとドキュメントデータベース

- 多対多の関係が必要じゃないならドキュメントモデルは有用
  - スキーマが単純
- 多対多の関係が必要ならやめたほうがいい
  - クエリを複数発行することになるのでアプリケーションのコードが複雑になる
  - パフォーマンスが低下する
- スキーマオンリード
  - データ構造は暗黙で、データの読み取り時に解釈される
- スキーマオンライト
  - スキーマは明示される
  - 書き込まれるデータはスキーマ準拠
  - リレーショナルデータベースのアプローチ
- ドキュメントデータベースはスキーマオンリード
- スキーマオンリードのメリット
  - k 図多くの種類のオブジェクトがあり、それぞれの種類のオブジェクトを個別のテーブルに保存することが現実的ではないとき
  - データの構造が外部のシステムによって決定され、こちらから制御できない。いつ変更されるかもわからないとき。
- アプリケーションがドキュメント全体にアクセスしないといけないときにドキュメントデータベースはメリットが有る
  - リレーショナルモデルは複数に分かれたテーブルにアクセスするために複数クエリ実行する
- ドキュメントの一部にしかアクセスしない場合はドキュメントモデルは無駄が大きい
  - ドキュメントにアクセスするとき、必ずデータベース全体をロードしないといけなくなるため
- ドキュメントを小さく保つ必要がある
- パフォーマンスの制約があるのでドキュメントデータベースが有効になる状況は減る

## ドキュメント及びリレーショナルデータベースの融合

- ほとんどの RDBMS は XML サポート、JSON ドキュメントをサポートしている
- ドキュメントデータベースはリレーショナル的な結合をクエリ言語でサポートしている
- ドキュメント的なデータを扱い、リレーショナルなクエリを実行できるハイブリッドモデルは将来的に良い方針

## データのためのクエリ言語

- 宣言的クエリ
  - SQL
  - 求めるデータパターンを記述するが、取得方法は指定しない
  - 並列実行が可能
- 命令的クエリ
  - IMS
  - CODASYL
  - 操作を指定し、指定した順序で実行するように指示する
  - 特定の順序を命令するので、並列実行できない

## MapReduce でのクエリ

大量ので 0 田を多くのマシンにまたがってまとめて処理するためのプログラミングモデル

- 宣言的クエリと命令的クエリの間
- map と reduce を基盤
  - pure で副作用があってはいけない
- 並列実行が可能

## グラフ型のデータモデル

- ノードとエッジで構成
- 多対多が一般的で、データ同士が複雑になってくるとグラフとしてモデル化するのが一般的
- プロパティグラフモデル
  - 頂点
    - ユニークな識別子
    - 外向きの辺の集合
    - 内向きの辺の集合
    - プロパティのコレクション（キーと値のペア）
  - 辺
    - ユニークな識別子
    - 辺の始まりの頂点（始点 head vertex）
    - 辺の終わりの頂点（終点 tail vertex）
    - ２つの頂点間の関係の種類を表すラベル
    - プロパティのコレクション（キーと値のペア）
  - 特徴３つ
    - 頂点は辺で他の頂点と接続
    - 頂点の入出力の辺を見つけるのが容易。グラフを探索できる。tail_vertex と head_vertex にはられたインデックスが探したい node と同じなのを見つける。
    - ラベルを貼ることで関係の種類を整理可能。
  - グラフのデータはリレーショナルデータベースで表現できるか
    - できるが多少困難
      - 必要になる結合がリレーショナルデータベースと違って事前にわからないから
    - 再帰共通テーブル式
      - SQL:1999 から使える
      - 可変長のパスをクエリでたどる
- トリプルストアモデル
  - おおよそプロパティグラフモデルと同じ
  - ３つの言明の形でデータを保存
    - 主語
      - Node
    - 述語
    - 目的語
      - データの値
        - (Lucy, age, 33)
          - 33 がこれ
      - 別の Node
        - (Lucy, marriedTo, alain) (Node, Edge, Node)
  - セマンティック Web
    - W3C のティム・バーナーズ＝リーによって提唱された、ウェブページの意味を扱うことを可能とする標準やツール群の開発によってワールド・ワイド・ウェブの利便性を向上させるプロジェクト。
    - RDF Resource Description Framework
      - さまざまなウェブサイトが一貫したフォーマットでデータを公開する仕組み
  - RDF データモデル
    - 冗長な記述
    - インターネット上でのデータ交換のために設計されたから
  - SPARQL クエリ言語
    - RDF データモデルを使うトリプルストアのためのクエリ言語

# 3 章

## ストレージと抽出

- 自分のアプリケーションに適したストレージエンジンを選択するべし
  - ストレージエンジンがなるべくパフォーマンスを発揮できるように
- log-structured ストレージエンジン
- ページ指向ストレージエンジン
  - BTree

## データベースを駆動するデータ構造

- 読み取り高速化のために index が必要
  - データから導出される追加のデータ構造
  - 書き込み時に index を更新する
    - 書き込みのパフォーマンスを悪化させる
      - そのかわりに読み取り時に早くなる
      - つまりトレードオフ
  - 開発者が index を選択する
    - データベースは通常全てに index を付与しない
  - ハッシュインデックス
    - キーバリュー型のデータ構造の場合
      - キーとバリューをそれぞれデータストレージに保存するときに、バイトオフセットを設定する
      - ハッシュマップにはバイトオフセットに対応した場所にキーとバリューの値を格納する
      - 取り出すときはこのバイトオフセットをシークする
      - キーバリューのデータが追加されるたびに、すべてのバイトオフセットが変動するので、反映するフェーズが発生する
    - コンパクション処理
      - 重複しているキーを捨てる
      - ディスク領域を確保
  - SSTable
    - Sorted String Table
    - ストレージ内のセグメントがキーで sort されている
    - セグメントのマージが用意
      - マージソートのアルゴリズムを使える
        - マージソートとは、与えられたデータ列を大小などの順序通りになるよう並べ替えるソート（整列）アルゴリズムの一つで、データ列を細かく分割し、整列しながら次第に併合（merge）していくもの。
      - 複数のセグメントで重複するキーが登場したときは、新しいセグメントで上書きする
    - ファイル中の特定のキーを探すときにいくつかのキーのオフセットだけ知っておけばいい
      - A,B,C,D で B を探したいときは、A と C の間にあるはずという見当がつけられるため
    - ツリー型のデータ構造でセグメントを管理する
      - インメモリツリーはバランスドツリーデータ構造
        - memtable
      - memtable が閾値よりでかくなったら、インメモリからディスクへ書き出し
        - このときすでにソート済み
      - 読み取り時には最新のセグメントのツリー探索、なかったら次に古いセグメントを探索
  - LSM ツリー
    - Log Structured Merge Tree
    - SSTable や memtable などが絡むインデックス構造
    - LSM ストレージエンジン
      - ソート済みファイルとコンパクションの原理を基盤とする
  - Bloom filter
    - ブルームフィルタは、1970 年に Burton H. Bloom が考案した空間効率の良い確率的データ構造であり、あるデータが集合の要素であるかどうかの判定に使われる。ただし判定は正確ではなくて、含まれていないのに含まれていると誤って判定すること偽陽性の可能性がある。
  - BTree
    - 非リレーショナルデータベースでも多く使われている
    - DB を固定サイズのブロックあるいはページに分割
    - 各ページには他のページへの参照がはられている
      - 各ページの参照数を branching factor
        - 通常数百
      - key が 100~199 までを他のページに分割し、そこのページへの参照をはるみたいな
    - リーフページ
      - 読みたいデータが入っているページ
    - キーの追加する場合
      - 100~199 をもつページに 135 というキーを追加する
      - 100~149 と 150~199 というページに分割し、参照元のページも 100~199 ではなくて、100~149 と 150~199 を参照とするように追加する

## BTree と LSMTree の比較

- BTree は読み取りが高速
- LSMTree は書き込みが高速

## トランザクション処理化、分析処理化？

- OLTP
  - Online transaction processing
  - 何らかのキーでインデックスを使い、少数のレコードをルックアップ、レコードの挿入や更新はユーザーの入力に基づいて実行される処理のこと
- OLAP
  - Online analytics processing
  - 分析目的で使う処理
  - 大量のレコードを取得
  - 取得したレコードを集計
- SQL は OLTP 型クエリと OLAP 型クエリをうまく扱えた柔軟な言語
- データウェアハウス
  - OLTP のシステムを分析目的で使わずに、別個のデータベースで分析を実行するときに使うデータベースのこと
  - データモデルはリレーショナルであることが一般的
    - SQL が分析的なクエリに適している
- データウェアハウスとリレーショナルな OLTP データベースは最適化が違うので、内部的には違う。
- データ処理はスタースキーマ（ディメンションモデル）を使っている
  - ファクトテーブルが中央にある
  - ファクトテーブルの各列は他のテーブル「ディメンションテーブル」への参照
  - 星のようにファクトテーブルを取り囲んでいるからスタースキーマ
- 行指向レイアウト
  - OLTP データベースのストレージ
  - 1 行の値が隣り合うように並ぶ
- 列指向レイアウト
  - それぞれの列すべての値を保存
  - 列数多くて行が多い、しかし検索は少数の列しか指定しない場合に有効

# 4 章

## エンコーディングと進化

- アプリケーションは進化、変化し続ける必要がある
- ローリングアップデート（段階的ロールアウト）
  - デプロイの際に新しいバージョンのノードが少しずつ古いバージョンのノードより増えていき、ダウンタイム無しでスムーズなデプロイを実現する手法

## データエンコードのフォーマット

- データの表現
  1. メモリ内で保持
  - CPU による操作やアクセスが効率的にできるようになっている
    - 構造体
    - リスト
    - 配列
    - ハッシュテーブル
    - オブジェクト
  - 通常はポインタが利用される
  2. 自己完結しているバイトの並び（例えば JSON ドキュメント）としてエンコード
  - ファイルにデータを書いたりネットワーク経由でデータ送信するため
  - ポインタは関係ないのでメモリ内で使われるデータ構造とは異なる
- この２つの表現間でなんらかの変換が必要
  - 1 => 2
    - エンコーディング
      - シリアライゼーション
      - マーシャリング
  - 2 => 1
    - デコーディング
      - パース
      - デシリアライゼーション
      - アンマーシャリング
- IEEE754
  - 小数計算の誤差
  - 計算する際には 2 進数に変換される
    - 10 進数 => 2 進数
      - 整数部分は % 2 していってあまりを下から並べたもの
        - 13
          - 13 % 2 = 6, 1
          - 6 % 2 = 3, 0
          - 3 % 2 = 1, 1
          - 1 % 2 = 0, 1
          - よって 1101
      - 小数部分は \* 2 していって上から並べたもの
        - .875
          - .875 \* 2 = 1.750
          - .750 \* 2 = 1.500
          - .500 \* 2 = 1.000
          - よって 111
      - 13.875 = 1101.111
  - 2 進数では 10 進数の小数は循環小数というものが出てくる
    - 0.1 = 0.0001100110011001100110011001100110011001100110011001101...
    - JS は 50 桁ぐらいで四捨五入する
    - この四捨五入によって誤差がでて、2 進数から X 進数に戻すときに誤差が出る
  - 小数部分をけすまでかけてその分後で割る
    - let a = 0.1 + 0.2 = 0.30000000000000004
    - a = Math.round(a \* 10)
    - a = a / 10
    - 0.3 になる
- 特定の言語でエンコーディングすると、その言語にロックインしてしまうのは良くない
  - CSV, JSON,XML のようなフォーマットに専用のバイナリエンコーディングができた
    - Apache Thrift
      - Facebook
    - Protocol Buffers
      - Google
      - 3 つのオプション
        - optional
        - required
        - repeated
    - Apache Avro
      - 書き込むのにスキーマが必要（エンコード）
        - ライタースキーマ
      - 読み込むのにスキーマが必要（デコード）
        - リーダースキーマ
- スキーマがあると
  - 静的型付け言語で型チェックが可能
  - 常に最新の状態に保たれるドキュメンテーションとみなせる

## データフローの形態

- データベース経由
  - RDB は新しい列を追加するときは null を入れる
  - マイグレーション
    - データを新しいスキーマにあわせて書き直すこと
- サービス経由
  - サーバーが公開する API を「サービス」という
  - サーバーそのものが他のサービスのクライアントになる
    - サーバーは DB にたいしてクライアントになる
    - サービス指向アーキテクチャ
      - あるサービスがあるサービスの機能やデータを必要とするさいにリクエストを発行するようなアプリケーションの構築方法
      - 別名「マイクロサービスアーキテクチャ」
      - それぞれのサービスが独立してデプロイして進化でき、変更とメンテナンスが容易であるべき
  - Web サービス
    - HTTP がサービス間のやり取りのプロトコルとして使われているサービス
  - RPC（リモートプロシージャプロトコル）
    - リモートにあるネットワークサービスへのリクエストの発行を、同一プロセス内でのプログラミング言語における関数やメソッド呼び出しと同じように見せようとする
      - 場所の透明性
    - RPC フレームワークが多数存在
      - Avro
      - gRPC
      - Thrift
    - RPC フレームワークの焦点は同一組織内のサービス間のリクエスト
    - メッセージブローカー
      - 一時的にリクエストを保存するもの

# 二部　イントロ

## 分散データ

データベースを分散したい理由

- スケーラビリティ
- 耐障害性/耐可用性
- レイテンシ

- 共有メモリアーキテクチャ
  - スケールアップ
  - 多くのディスクを１つの OS の下に集結、任意の CPU が任意のメモリやディスクにアクセス
- 共有ディスクアーキテクチャ

  - 独立した CPU を複数用意、データはマシン間で共有されるディスクアレイに保存

- シェアードナッシング

  - スケールアウト
  - 各マシンは「ノード」と呼ばれる

- レプリケーション
  - 同じデータのコピーを複数のノードに保持する
- パーティショニング
  - 巨大なデータベースをパーティションと呼ばれる小さなサブセットに分割する

# 5 章

## レプリケーション

- データを地理的にユーザーの近くで保持しておく
  - レイテンシをさげる
- 一部に障害があってもシステムが動作し続けられるようにする
  - 可用率を高める
- 読み取りのクエリを処理するマシン数をスケールアウトする
  - スループットを高める

## リーダーとフォロワー

- レプリカ
  - データベースのコピーを保存する各ノード
- レプリカ全体にデータが保存されたことを証明するには？
  - リーダーベースレプリケーション
    - レプリカの一つを「リーダー（プライマリ）」とする
    - 他を「フォロワー（リードレプリカ、セカンダリ）」とする
    - 最初にリーダーにリクエストが届いてローカルストレージにコピー
    - リーダーはデータを「レプリケーションログ」あるいは「変更ストリーム」の一部としてフォロワーに送信
    - フォロワーはリーダーと同じようにデータを更新
    - 書き込みはリーダーのみ受付、読み取りはリーダーとフォロワーどっちも OK
- 同期的か非同期的か
  - ケース
    - リーダーとフォロワー 1 までのデータの保存は同期的
    - フォロワー 2 以降は非同期的
  - 同期的なメリット
    - リーダーとフォロワーでデータの整合性が担保される
  - 同期的なデメリット
    - フォロワーが一つでも応答しなくなったらリーダーが処理を待ち続ける
  - メリットデメリットを考慮し、フォロワー１つとリーダーを同期、残りのフォロワーは非同期で処理するのが通常
    - 準同期型 semi synchronous
  - 非同期のメリット
    - フォロワーが遅延しててもリーダーが書き込み処理継続可能
  - 非同期のデメリット
    - リーダーに障害が発生したらフォロワーがレプリケーションされてなかった書き込みはすべて消失
- フォロワーを追加するとき
  - 新しいフォロワーがリーダーの正確なコピーを持っていることの保証は？
    - ロックすればいい
      - ロックしたら書き込めなくなるので高可用性に反する
    - 実はダウンタイムなしにできる
      - とある段階でリーダーのスナップショットをとる
      - スナップショットを新しいフォロワーのノードにコピー
      - フォロワーはリーダーにスナップショット後のデータを要求
      - データをもとにフォロワーのデータを更新（キャッチアップ）
- ノードがダウンしたら
  - 一つのノードがダウンしても、システム全体が生きるようにするべき
    - フォロワーがダウン
      - ログからネットワークが切れる最後のトランザクションを知って、その後のデータをすべてリーダーに要求
    - リーダーダウン
      - いくつかのプロセスが発生（フェイルオーバー）
        - フォロワーのいずれかをリーダーに昇格
          - リーダーのデータ変更に一番最近まで追従していたものが選出される
        - クライアントはその新しいリーダーを書き込み先に再設定
        - 他のフォロワーは新しいリーダーからデータ受信するようにする
      - フェイルオーバーの問題点
        - 古いリーダーのデータを破棄して、古いリーダーをクラスタに復帰させたら、永続性の期待に反する
        - 書き込みの破棄はデータベースが他のシステムと連携している場合に不具合が生じる場合がある
          - データの整合性が合わなくなる
        - スプレットブレイン
          - ２つのノードがリーダーとなってしまうこと
        - リーダーが落ちたと判断するタイムアウトの適切な時間設定
          - 長い
            - リカバリに時間かかる
          - 短い
            - 不要なフェイルオーバーが発生
- レプリケーションログ
  - レプリケーションの舞台裏
    - 最もシンプルなケース
      - リーダーは書き込みリクエスト（ステートメント）をログに記録
      - フォロワーに送信
      - フォロワーはログの中の insert、update、delete を解析、実行
    - 問題点
      - 現在日時を取得するとかは、それぞれのレプリカで異なる結果を生じさせる
      - SQL 実行順に意味がある場合
        - 並列で処理できない
    - 問題点の回避
      - リーダーは関数の実行結果をフォロワーに送信して、すべてのフォロワーがリーダーと同じ値を得られるようにする
- WAL Write-ahead log
  - データベースシステムにおいて原子性と永続性を実現するためのテクニックのひとつ
  - プログラムがある処理を実行中にマシンの電源が落ちた場合を考える。マシンが再起動した後、プログラムは電源断の前に実行していた処理が成功したのか、途中まで進んでいて中断されたのか、失敗したのかを検知する必要がある。ログ先行書き込みが行われていた場合、プログラムはログをチェックして、電源が落ちたときに本来行われていなければならなかった内容と、実際に行われた内容とを比較する。この比較によって、プログラムは処理の開始時までアンドゥするか、中断された処理を再開して完了させるか、そのままの状態にしておくかを判断することができる。
  - このログはレプリカ構築にそのまま利用可能
    - リーダーはログをディスクに書き込むと同時にログをフォロワーに送信
    - フォロワーがそのログを処理すれば、リーダーと同じデータ構造がコピーできる
  - WAL は PostgreSQL と Oracle で利用されている
  - ログはデータを非常に低レベルで記述している
    - 「どのディスクブロックのどのバイトが変更された」みたいなこと
  - レプリケーションがストレージエンジンと密接なつながりを持つことになる
  - データベースがストレージフォーマットを変更したら、リーダーとフォロワーは一緒のフォーマットで動かさないといけないので、これらの間でフォーマットの差異がでてはいけない
    - まずフォロワーをアップグレード
    - フェイルオーバーでアップグレードされたノードの一つを新しいリーダーにする
    - 以上でダウンタイムなしにアップグレード可能
  - WAL の転送によるレプリケーションの場合、レプリケーションプロトコル上、バージョンのミスマッチは許されていないことが多い
    - ダウンタイムが必要になってくる
- 論理ログ
  - ストレージエンジンの内部から独立したレプリケーションログのこと
  - 行ベース
    - 挿入
      - ログにはすべての列の新しい値
    - 削除
      - ログには削除された行を特定するのに十分な情報
      - 大体プライマリキー
      - プライマリキーがなかったら削除前のすべての列を値をログに記録
    - 更新
      - ログには更新された行を特定するのに十分な情報
      - すべての列の新しい値
        - 最低でも変更されたすべての列の新しい値
  - 独立しているので後方互換性を保ちやすい
    - リーダーとフォロワーで異なるバージョンのデータベースソフトウェアが動作可能
    - 異なるストレージエンジンを動作可能
  - 論理ログはパースしやすい
    - 外部システムへ送信したいときに便利
      - データウェアハウス
      - キャッシュの構築
    - 「変更データのキャプチャ」と呼ばれる
- トリガベースレプリケーション
  - トリガ、ストアドプロシージャ
    - データが変更されたときに任意のアプリケーションコードを自動実行させるやつ
    - データの変更を別のテーブルに記録可能になるので、外部のプロセスからデータを呼び出せる
    - トリガやストアドプロシージャで任意の変更を加えられたデータを呼び出し、データの変更をレプリケーションできる
    - バグの温床になりがちだが、柔軟性が高い

## レプリケーションラグにまつわる問題

- 読み取りスケーリングアーキテクチャ
  - 書き込みはリーダーがやるが、読み取りはどのフォロワーでも可能
    - リーダーの負荷が減る
    - リクエストが有ったところに近いレプリカがレスポンスを返すことも可能
  - フォロワー増やすとリクエストの処理内容増やせる
  - 非同期のレプリケーションのみ有効
    - 同期的だと１つのノードが不全になるとすべてが止まってしまう
    - ノードが増えるとこのリスクは高まるばかり
  - 非同期だとしても、フォロワーがまだリーダーからデータを受信してないかもしれないのでデータが古い可能性あり
    - これは一時的
    - 最終的にはリーダーと一致する
      - 「結果整合性」
  - レプリケーションラグ
    - リーダーとフォロワー間でのデータの整合性が取れていないラグのこと
    - 一時的な場合だったら OK
    - ラグが増えてしまう可能性がある
      - システム容量限界近くで運用
      - ネットワークの問題

## レプリケーションラグが生じると起こりやすい問題と解決策

- ユーザが送信したデータを取得できない

  - リーダーに送られたデータがまだフォロワーに反映されておらず、フォロワーに問い合わせた結果データが取得できない
  - read-after-write 一貫性
    - 自分で投入した更新が必ず反映されていることを保証するもの
  - 解決策
    - ユーザーが変更したかもしれないものはリーダーから読み取りを行い、それ以外はフォロワーから読み取る
    - 最新の更新から X 分以内の読み取りはリーダから読み取る
    - ユーザが最後に行った書き込みのタイムスタンプと、レプリカがその時刻までに行われた更新を反映しているかをシステムが判断。違ったら他のレプリカに任せる
  - ユーザーが複数のデバイスでサービスにアクセスしていると問題が複雑
    - クロスデバイス read-after-write
    - それぞれ違うアクセスになってしまうと、異なるユーザ扱いになってしまうので、すべてのユーザのデバイスを同じデータセンタへルーティングしなければならないかも

- 過去のデータがユーザに露出してしまう
  - フォロワーがリーダーと同期しているフォロワー A とまだ同期していないフォロワー B にそれぞれユーザが読み取りを実行した場合、違う結果が帰ってきてしまう
    - B に読み取りした場合、過去の情報が見えてしまっている
  - 解決策
    - モノトニック読み取り
      - 一度読み取りを行うと、同じ値か、それよりも新しい値を取得する
      - 何度読み取りを行っても、同じレプリカに読み取りを行う前提
        - ユーザー ID のハッシュによってレプリカを決めるとか
- 順番に整合性がない
  - 書き込んだ順番に意味がある場合、読み取る順番にも意味がある。
    - A「こんにちは。私は A です。あなたは？」B「こんにちは A。私は B です」が、B「こんにちは A。私は B です」A「こんにちは。私は A です。あなたは？」の順番にはならない
  - 分散データベースはパーティションが独立して動くので、データを読み取ろうとしたときに順番が保証されていない可能性がある。
    - レプリケーションの時間差によって生じる
  - 解決策
    - 必ず同じパーティションに関連性のあるデータ一式を書かれるようにする
- 非同期であるレプリケーションを同期的に扱うと問題が生じる
- トランザクション
  - データベースが提供する「適切に処理をおこなう」方法
  - シングルノードだと有用だった
  - スケーラブルなシステムだと、結果整合性は不可避だし、パフォーマンスや可用性の面でトランザクションが負担でかすぎる

## マルチリーダーレプリケーション

- マルチリーダー構成
  - 複数のノードが書き込みを受け付けること
- 単一のデータセンターだったらマルチリーダー構成は不要
- 複数のデータセンターには有効
  - 各々のデータセンターでリーダーノードが存在し、リーダーはフォロワーと、異なるデータセンターにデータを送信
    - レイテンシが下がる
  - リーダーが障害起きたら、それぞれのデータセンターのノードがフェイルオーバーするので、データセンターで独立してフェイルオーバーが可能
  - データセンター内のローカルネットワークで完結できるので、公開ネットワークの障害に強くなる。一時的なネットワーク障害だったら書き込みが継続して可能
- 異なるデータセンターにデータを送る際に、書き込みデータの「翔太乙の解決 conflict resolution」が必要になる
- 可能であれば、マルチリーダーレプリケーションは避けるべきであると思われている
  - 多くの DB にとってこの機能は後付け
  - 設定上の落とし穴、データベースの他の機能との意図せぬ相互作用
    - 自動インクリメントのキー、トリガ、整合性制約
- マルチリーダーレプリケーションはオフラインのときにアプリケーションを動作させ続ける必要があるときに有効
  - オフライン時にスケジュールを書き込む
  - オンラインになったら、そのスケジュールは確定されて、他のデバイスと同期されないといけない
  - このとき、スケジュールを書き込んだデバイスがリーダーのように振る舞う
- リアルタイムコラボレーティブ編集アプリは、マルチリーダーレプリケーションであるといえる
  - それぞれのユーザーが書き込む（リーダー）
  - そのユーザーのデバイスに反映される（フォロワー）
  - 同時に編集しているユーザーに反映される（異なるデータセンターに送信）

## 書き込みの衝突
