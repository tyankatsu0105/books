# 1 章

## 演算指向よりもデータ指向

高度に発達した CPU や処理能力といったスペックが制約条件にはならない。
データ量や複雑さ、データの変化する速度が大きな問題。
以下のような機能が、今日のアプリケーションでは必要。

- データベース
- キャッシュ
- 検索インデックス
- ストリーム能力
- バッチ処理

## ソフトウェアシステムにおける 3 つの重要な課題

- 信頼性
  - なにか問題があっても正しく動作し続ける
- スケーラビリティ
  - システムの成長に追従できる
- メンテナンス性
  - 時間が経過したシステムに、多くの開発者が生産的に関われる

## 信頼性

- fault

  - 問題を起こしうるもの。
  - 障害のことではない。

- fault tolerant or resilient
  - 耐障害性を持っていること
  - fault を見越して対処できるシステムであること
- すべての fault に耐えられるってことではない。
- ある種の fault に対する体制について議論することが大事。
- fault が障害を引き起こさないような耐障害性の仕組みを設計しよう。

- 意図的に fault を発生させて、耐障害性の仕組みを動作させてテストする。

  - 警告なしにランダムでここのプロセスを kill するとか
  - 多くの致命的なバグはエラー処理が貧弱なことによるものであるため
  - fault が生じたときに正しく対処されるというか悪心を強める
  - Netflix の Chaos Monkey

- fault は耐性を持つようにすることが望ましい
  - セキュリティ問題のように、回避したほうが望ましいものもある

## ハードウェアの障害

- ハードディスクは壊れる
- 冗長性をもたせて回避しよう
  - ディスクの RAID 構成
    - https://www.rescue-center.jp/explanation/raid/type.html
  - サーバー電源二重化
  - など
- 何かが壊れても冗長な代替が、置き換えまでの時間を稼いでくれる
- 扱うデータ量の増加やアプリケーションに求める処理量の増加で大量のマシンを扱う
  - ハードウェアの fault も増加傾向にある
  - ハードウェアの冗長化とソフトウェアの耐障害性を使う
    - マシン全体が失われても耐えられるようなシステムへの移行が進んでいる
    - rolling upgrade
      - ソフトウェアの更新、入れ替えの方法の一つで、稼働中のシステムを完全には停止させずに徐々に新しいものに入れ替えていく方式

## ソフトウェアのエラー

- ソフトウェアの fault はシステム内でのエラーがある
  - 予測が難しい
  - ノード間で相関性がある
  - ハードウェアの fault よりも多くの障害に繋がりやすい
    - ソフトウェアのバグ
    - プロセスの暴走
    - 依存しているサービスの問題
    - カスケード障害
      - 1 つの fault が他のコンポーネントの fault を次々に引き起こしていく
- 手っ取り早い解決策はない
  - 些細なことの積み重ね
    - 徹底したテスト
    - プロセスの分離
    - 計測
    - 挙動分析

## ヒューマンエラー

- 人間には信頼性がない
- サービス障害の一番多い原因はオペレータの設定ミス
- 信頼性を高めるためにすること
  - 正しいことをしやすく、間違ったことをしにくいシステム設計
  - 障害になりやすいところから、間違いを起こしやすい箇所から分離する
  - 徹底的なテスト
  - モニタリング

## スケーラビリティ

負荷の増大に対してシステムが対応できる能力のこと

## 負荷の表現

- 負荷のパラメータ
  - 負荷を表現する数値
  - Twitter
    - ユーザーごとのフォロワーの分布
    - ファンアウトの負荷を決めるので、負荷パラメータになる

## パフォーマンスの表現

- 負荷の増大したときに調査すること

  - 負荷パラメータを増やしながらシステムリソースを一定に保つと、パフォーマンスにどのような影響があるか
  - 負荷パラメータを増やしてパフォーマンスを一定に保つにはリソースをどれほど増やせばいいか

- パフォーマンスを計測しなければ、負荷がわからない
- バッチ処理
  - スループットを見る
    - コンピュータやネットワーク機器が単位時間あたりに処理できるデータ量のこと。あるいは、その数値を使ってデータ処理能力やデータ転送速度を表す。
    - 数値の単位は「bps」「kbps」「Mbps」で 1 秒あたりのデータ量をビット数で表す。
- オンラインシステム

  - レスポンスタイムを見る

- レスポンスタイムを見る
  - 外れ値が出る時がある
    - レスポンスに時間がかかった場所
    - いろいろな要因でそうなる
  - 平均を見る
    - 算術平均
      - n 個の合計値を n で割った数
        - 1+5+6/
    - 平均を見ても、典型的なレスポンスタイムは見れない
      - どれほどのユーザが遅延を日々体験しているのかわからない
  - percentile を見る
    - 平均を見るよりもいい
    - median（中央値）
      - レスポンスタイムを見るのにいい指標
      - リクエストの半分が中央値未満、もう半分が以上と区別できるのが中央値だから
      - 50percentile とも呼ばれる
        - p50
    - 外れ値を見るのは p90,p99,p999(99.9%)がよく使われる
      - テイルレイテンシとも言う
      - これらの percentile に引っかかるユーザーは大量のデータを扱っていることが推測できる
      - つまり重要顧客
      - このユーザでも満足してもらえるユーザ体験を提供することは重要
      - p999 の改善はかなり負担が大きくてメリットが少ない
    - percentile は SLO や SLA に用いられる指標
      - SLA
        - サービス レベル アグリーメント
        - SLA (サービス レベル アグリーメント) は、アップタイム、応答性、責任などの測定可能な指標に関する、プロバイダーとクライアント間の契約です。これらの契約は通常、会社の新しいビジネス チームや法務チームによって作成されていて、お客様に対する約束とその約束を守れなかった場合の結果を表します。通常、この結果には、違約金、サービス クレジット、ライセンス延長が含まれます。
      - SLO
        - サービス レベル目標
        - SLO (サービス レベル目標) とは、アップタイムや応答時間などの特定の指標に関する SLA 内の合意です。したがって、SLA がお客様とお客様の顧客との間の正式な合意であれば、SLO はお客様から当該顧客に対する個々の約束です。SLO は、顧客の期待値を設定して、IT チームと DevOps チームが達成および測定する必要がある目標をチーム メンバーに伝えるためのものです。
      - 例）SLA = レスポンスの中央値が 200 ミリ秒以下で、p99 が 1 秒以下ならサービスは動作中で、99.9%の時間動作していなければならない
    - HOL
    - head-of-line blocking
      - 大きな percentile のレスポンスはキューイングの遅延であることがあって、サーバーが同時に処理できる数は限られている。低速リクエストに引っ張れられて以降のリクエストの処理が待たされてしまう現象のこと。
      - サーバーがうまくさばけても HOL blocking が発生したらクライアントは待たされている。
      - クライアントでレスポンスタイムを計測するのが重要
  - テイルレイテンシの増幅
    - 複数のバックエンドのレスポンスを待っているクライアントがいる
    - どれかひとつでもバックエンドのレスポンスが遅いものがある
    - 結果的にクライアントはそのバックエンドの処理を待たなければいけなくなる

## 負荷への対処のアプローチ

- スケールアウト
  - 水平のスケーリング
  - マシンを分散して負荷を分散
- スケールアップ
  - 垂直のスケーリング
  - マシンスペック上げる
- shared nothing architecture
  - スケールアウトで負荷分散させること
  - ハイエンドマシンは高価
    - だがシステムがシンプルになる
- スケールアウトとスケールアップをミックスするとコストを抑えられる
  - いくつかの強力なマシンをつかって、小さなマシンを大量に使わない
- elastic
  - 負荷の増大を検知して、自動でコンピューティングリソースを追加できるシステム

## メンテナンス性

3 つの設計原理でレガシーとなるソフトウェアを生み出さないようにする

- 運用性
  - システムをスムーズに動作させ続けるために運用チームが扱いやすいようにする
- 単純性
  - 複雑性を取り除き、新しいエンジニアがシステム理解しやすいようにする
    - big ball of mud
      - 複雑さにはまり、メンテナンスコストが増えたアプリケーションのこと
      - 避けたほうがいい
    - 単純にすることは機能を減らすことではない
      - 「偶発的な複雑さ」を取り除くということ
        - ソフトウェアが解決しようとしている問題がもともとは持っておらず、実装からのみ生じている複雑さ
      - 抽象化で「偶発的な複雑さ」を取り除く
- 進化性
  - 要求の変化に応じてシステムを変えられるようにする
  - 拡張性
  - 修正の容易性
  - plasticity
    - 塑性そせい
    - 力を加えて変形させたとき、永久変形を生じる物質の性質のことを指す。

## 要求

アプリケーションが有益であるための様々な要求

- 機能的な要求
  - データの保存、取り出し、検索、処理
- 非機能的な要求
  - セキュリティ
  - 信頼性
  - コンプライアンス
  - スケーラビリティ
  - 互換性
  - メンテナンス性

# 2 章

## リレーショナルモデルとドキュメントモデル

- リレーショナルモデル
  - SQL のデータモデルと同じ
  - リレーション（SQL ではテーブル）とタプル（SQL では行）の集合
- ドキュメントモデル

  - NoSQL Not Only SQL
  - ドキュメント形式のデータを保存できる
    - JSON 形式
    - XML 形式
  - スキーマがない利点

- リレーショナルデータベースはいろいろな形式の非リレーショナルデータベースと組み合わせて使われていく
  - ポリグロットパーシステンス polyglot persistence
    - 複数モデルの永続化

## 多対一と多対多の関係

- 「地域名」のように自由に入力できるデータ保存の際に、
  - 人間にとって意味のある「文字列」として保存する
    - 将来どこかで変更される可能性がある
  - ユニークな値として「ID」で保存する
    - 変更する必要がない
    - ID が指している情報は変えられる
- 複製は極力排除しないといけない
  - 正規化の鍵
  - ID での値管理はこれに有力
- ドキュメントモデルは多対一に適合できない
  - 1 つの地域に大勢が住んでいる、１つの業界に大勢が働いている
  - 結合のサポートが弱い
- リレーショナルは結合が用意
  - ID を関連するテーブルを覗いたり
- ドキュメントモデルに適応したデータベースであっても、後にデータ同士のつながりを持つことが考えられる
  - そうなったら機能しない

## ドキュメントデータベースは歴史を繰り返すのか

- Information Management System (IMS)
  - IBM が作った 70 年代のビジネスデータの処理用の最も一般的なデータベース
  - 階層モデルというデータモデル
    - ドキュメントデータベースと似ている
- 階層モデルの制約
  - 多対多が難しい
  - 一対多
- 階層モデルの制約を解決するために登場したデータモデル
  - ネットワークモデル
    - 次第に廃れた
    - 別名 CODASYL モデル
      - Conferrence on Data System Language
    - 階層モデルを一般化したもの
    - レコードは必ず 1 つ以上親を持つ
    - レコード間のリンクはポインタみたいなやつ
    - あるレコードにアクセスするためにはルートからリンクに沿ってパスをたどる
      - アクセスパス
    - パスがいろいろあるためいろいろなパスをたどる必要がある
      - もとめるデータへのパスが不明
    - データモデルに変更を加えるとアクセスパスがへんこうするため、変更が難しい
  - リレーショナルモデル
    - SQL
    - クエリオプティマイザがいろいろやってくれる
      - クエリの実行順序
      - どのインデックスを使うか判断
      - SQL でどのデータがほしいかを書くだけで、どのように取得するかを毎回考えて決定してくれる
        - データベース管理システム（DBMS）の持つ機能の一つで、外部から投入された問い合わせ（クエリ）群を最も効率よく処理できるような実行計画を立てる機能を「クエリオプティマイザ」あるいは単にオプティマイザという。DBMS が内部に持つ機能で、性能を決定付ける最も重要な機能の一つだが、利用者が明示的に操作や指示、設定などを行うことは（でき）ないため存在が意識されることは少ない。
    - ネットワークモデルとの違いはクエリオプティマイザの存在
      - アプリケーション開発者ではなくて、クエリオプティマイザにいろいろ操作を委譲できる
    - インデックスを貼れば、クエリは自動でインデックスを使う
    - データモデルへの変更がはるかに容易
- リレーショナルデータベースとドキュメントデータベースに「多対一た多対多の関係の表現」で違いはない
  - リレーショナルモデルは「外部キー」
  - ドキュメントモデルは「ドキュメント参照」
- ドキュメントデータベースは CODASYL を繰り返してない

## 今日のリレーショナルデータベースとドキュメントデータベース

- 多対多の関係が必要じゃないならドキュメントモデルは有用
  - スキーマが単純
- 多対多の関係が必要ならやめたほうがいい
  - クエリを複数発行することになるのでアプリケーションのコードが複雑になる
  - パフォーマンスが低下する
- スキーマオンリード
  - データ構造は暗黙で、データの読み取り時に解釈される
- スキーマオンライト
  - スキーマは明示される
  - 書き込まれるデータはスキーマ準拠
  - リレーショナルデータベースのアプローチ
- ドキュメントデータベースはスキーマオンリード
- スキーマオンリードのメリット
  - k 図多くの種類のオブジェクトがあり、それぞれの種類のオブジェクトを個別のテーブルに保存することが現実的ではないとき
  - データの構造が外部のシステムによって決定され、こちらから制御できない。いつ変更されるかもわからないとき。
- アプリケーションがドキュメント全体にアクセスしないといけないときにドキュメントデータベースはメリットが有る
  - リレーショナルモデルは複数に分かれたテーブルにアクセスするために複数クエリ実行する
- ドキュメントの一部にしかアクセスしない場合はドキュメントモデルは無駄が大きい
  - ドキュメントにアクセスするとき、必ずデータベース全体をロードしないといけなくなるため
- ドキュメントを小さく保つ必要がある
- パフォーマンスの制約があるのでドキュメントデータベースが有効になる状況は減る

## ドキュメント及びリレーショナルデータベースの融合

- ほとんどの RDBMS は XML サポート、JSON ドキュメントをサポートしている
- ドキュメントデータベースはリレーショナル的な結合をクエリ言語でサポートしている
- ドキュメント的なデータを扱い、リレーショナルなクエリを実行できるハイブリッドモデルは将来的に良い方針

## データのためのクエリ言語

- 宣言的クエリ
  - SQL
  - 求めるデータパターンを記述するが、取得方法は指定しない
  - 並列実行が可能
- 命令的クエリ
  - IMS
  - CODASYL
  - 操作を指定し、指定した順序で実行するように指示する
  - 特定の順序を命令するので、並列実行できない

## MapReduce でのクエリ

大量ので 0 田を多くのマシンにまたがってまとめて処理するためのプログラミングモデル

- 宣言的クエリと命令的クエリの間
- map と reduce を基盤
  - pure で副作用があってはいけない
- 並列実行が可能

## グラフ型のデータモデル

- ノードとエッジで構成
- 多対多が一般的で、データ同士が複雑になってくるとグラフとしてモデル化するのが一般的
- プロパティグラフモデル
  - 頂点
    - ユニークな識別子
    - 外向きの辺の集合
    - 内向きの辺の集合
    - プロパティのコレクション（キーと値のペア）
  - 辺
    - ユニークな識別子
    - 辺の始まりの頂点（始点 head vertex）
    - 辺の終わりの頂点（終点 tail vertex）
    - ２つの頂点間の関係の種類を表すラベル
    - プロパティのコレクション（キーと値のペア）
  - 特徴３つ
    - 頂点は辺で他の頂点と接続
    - 頂点の入出力の辺を見つけるのが容易。グラフを探索できる。tail_vertex と head_vertex にはられたインデックスが探したい node と同じなのを見つける。
    - ラベルを貼ることで関係の種類を整理可能。
  - グラフのデータはリレーショナルデータベースで表現できるか
    - できるが多少困難
      - 必要になる結合がリレーショナルデータベースと違って事前にわからないから
    - 再帰共通テーブル式
      - SQL:1999 から使える
      - 可変長のパスをクエリでたどる
- トリプルストアモデル
  - おおよそプロパティグラフモデルと同じ
  - ３つの言明の形でデータを保存
    - 主語
      - Node
    - 述語
    - 目的語
      - データの値
        - (Lucy, age, 33)
          - 33 がこれ
      - 別の Node
        - (Lucy, marriedTo, alain) (Node, Edge, Node)
  - セマンティック Web
    - W3C のティム・バーナーズ＝リーによって提唱された、ウェブページの意味を扱うことを可能とする標準やツール群の開発によってワールド・ワイド・ウェブの利便性を向上させるプロジェクト。
    - RDF Resource Description Framework
      - さまざまなウェブサイトが一貫したフォーマットでデータを公開する仕組み
  - RDF データモデル
    - 冗長な記述
    - インターネット上でのデータ交換のために設計されたから
  - SPARQL クエリ言語
    - RDF データモデルを使うトリプルストアのためのクエリ言語

## ストレージと抽出

- 自分のアプリケーションに適したストレージエンジンを選択するべし
  - ストレージエンジンがなるべくパフォーマンスを発揮できるように
- log-structured ストレージエンジン
- ページ指向ストレージエンジン
  - BTree

## データベースを駆動するデータ構造

- 読み取り高速化のために index が必要
  - データから導出される追加のデータ構造
  - 書き込み時に index を更新する
    - 書き込みのパフォーマンスを悪化させる
      - そのかわりに読み取り時に早くなる
      - つまりトレードオフ
  - 開発者が index を選択する
    - データベースは通常全てに index を付与しない
  - ハッシュインデックス
    - キーバリュー型のデータ構造の場合
      - キーとバリューをそれぞれデータストレージに保存するときに、バイトオフセットを設定する
      - ハッシュマップにはバイトオフセットに対応した場所にキーとバリューの値を格納する
      - 取り出すときはこのバイトオフセットをシークする
      - キーバリューのデータが追加されるたびに、すべてのバイトオフセットが変動するので、反映するフェーズが発生する
    - コンパクション処理
      - 重複しているキーを捨てる
      - ディスク領域を確保
  - SSTable
    - Sorted String Table
    - ストレージ内のセグメントがキーで sort されている
    - セグメントのマージが用意
      - マージソートのアルゴリズムを使える
        - マージソートとは、与えられたデータ列を大小などの順序通りになるよう並べ替えるソート（整列）アルゴリズムの一つで、データ列を細かく分割し、整列しながら次第に併合（merge）していくもの。
      - 複数のセグメントで重複するキーが登場したときは、新しいセグメントで上書きする
    - ファイル中の特定のキーを探すときにいくつかのキーのオフセットだけ知っておけばいい
      - A,B,C,D で B を探したいときは、A と C の間にあるはずという見当がつけられるため
    - ツリー型のデータ構造でセグメントを管理する
      - インメモリツリーはバランスドツリーデータ構造
        - memtable
      - memtable が閾値よりでかくなったら、インメモリからディスクへ書き出し
        - このときすでにソート済み
      - 読み取り時には最新のセグメントのツリー探索、なかったら次に古いセグメントを探索
  - LSM ツリー
    - Log Structured Merge Tree
    - SSTable や memtable などが絡むインデックス構造
    - LSM ストレージエンジン
      - ソート済みファイルとコンパクションの原理を基盤とする
  - Bloom filter
    - ブルームフィルタは、1970 年に Burton H. Bloom が考案した空間効率の良い確率的データ構造であり、あるデータが集合の要素であるかどうかの判定に使われる。ただし判定は正確ではなくて、含まれていないのに含まれていると誤って判定すること偽陽性の可能性がある。
  - BTree
    - 非リレーショナルデータベースでも多く使われている
    - DB を固定サイズのブロックあるいはページに分割
    - 各ページには他のページへの参照がはられている
      - 各ページの参照数を branching factor
        - 通常数百
      - key が 100~199 までを他のページに分割し、そこのページへの参照をはるみたいな
    - リーフページ
      - 読みたいデータが入っているページ
    - キーの追加する場合
      - 100~199 をもつページに 135 というキーを追加する
      - 100~149 と 150~199 というページに分割し、参照元のページも 100~199 ではなくて、100~149 と 150~199 を参照とするように追加する

## BTree と LSMTree の比較

- BTree は読み取りが高速
- LSMTree は書き込みが高速

## トランザクション処理化、分析処理化？

- OLTP
  - Online transaction processing
  - 何らかのキーでインデックスを使い、少数のレコードをルックアップ、レコードの挿入や更新はユーザーの入力に基づいて実行される処理のこと
- OLAP
  - Online analytics processing
  - 分析目的で使う処理
  - 大量のレコードを取得
  - 取得したレコードを集計
- SQL は OLTP 型クエリと OLAP 型クエリをうまく扱えた柔軟な言語
- データウェアハウス
  - OLTP のシステムを分析目的で使わずに、別個のデータベースで分析を実行するときに使うデータベースのこと
  - データモデルはリレーショナルであることが一般的
    - SQL が分析的なクエリに適している
- データウェアハウスとリレーショナルな OLTP データベースは最適化が違うので、内部的には違う。
- データ処理はスタースキーマ（ディメンションモデル）を使っている
  - ファクトテーブルが中央にある
  - ファクトテーブルの各列は他のテーブル「ディメンションテーブル」への参照
  - 星のようにファクトテーブルを取り囲んでいるからスタースキーマ
- 行指向レイアウト
  - OLTP データベースのストレージ
  - 1 行の値が隣り合うように並ぶ
- 列指向レイアウト
  - それぞれの列すべての値を保存
  - 列数多くて行が多い、しかし検索は少数の列しか指定しない場合に有効

## エンコーディングと進化
