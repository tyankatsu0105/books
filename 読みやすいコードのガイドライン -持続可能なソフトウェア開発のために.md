<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [可読性の重要性](#%E5%8F%AF%E8%AA%AD%E6%80%A7%E3%81%AE%E9%87%8D%E8%A6%81%E6%80%A7)
- [可読性が重要じゃない場合](#%E5%8F%AF%E8%AA%AD%E6%80%A7%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%98%E3%82%83%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88)
- [可読性が重要な場合](#%E5%8F%AF%E8%AA%AD%E6%80%A7%E3%81%8C%E9%87%8D%E8%A6%81%E3%81%AA%E5%A0%B4%E5%90%88)
- [土台が大事](#%E5%9C%9F%E5%8F%B0%E3%81%8C%E5%A4%A7%E4%BA%8B)
- [可読性と評価](#%E5%8F%AF%E8%AA%AD%E6%80%A7%E3%81%A8%E8%A9%95%E4%BE%A1)
  - [可読性評価の指標](#%E5%8F%AF%E8%AA%AD%E6%80%A7%E8%A9%95%E4%BE%A1%E3%81%AE%E6%8C%87%E6%A8%99)
    - [単純](#%E5%8D%98%E7%B4%94)
    - [意図が明確](#%E6%84%8F%E5%9B%B3%E3%81%8C%E6%98%8E%E7%A2%BA)
    - [独立性が高い](#%E7%8B%AC%E7%AB%8B%E6%80%A7%E3%81%8C%E9%AB%98%E3%81%84)
    - [構造化されている](#%E6%A7%8B%E9%80%A0%E5%8C%96%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B)
  - [アーキテクチャやプログラミングテクニックを採用するときに重要なこと](#%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%82%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF%E3%82%92%E6%8E%A1%E7%94%A8%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AB%E9%87%8D%E8%A6%81%E3%81%AA%E3%81%93%E3%81%A8)
  - [複雑性が増す事態をどう対処するか](#%E8%A4%87%E9%9B%91%E6%80%A7%E3%81%8C%E5%A2%97%E3%81%99%E4%BA%8B%E6%85%8B%E3%82%92%E3%81%A9%E3%81%86%E5%AF%BE%E5%87%A6%E3%81%99%E3%82%8B%E3%81%8B)
  - [議論で本質的な問題について話す](#%E8%AD%B0%E8%AB%96%E3%81%A7%E6%9C%AC%E8%B3%AA%E7%9A%84%E3%81%AA%E5%95%8F%E9%A1%8C%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E8%A9%B1%E3%81%99)
    - [bike shedding](#bike-shedding)
  - [KISS](#kiss)
  - [単一責任の原則](#%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E3%81%AE%E5%8E%9F%E5%89%87)
- [命名](#%E5%91%BD%E5%90%8D)
  - [いい命名は可読性を高める](#%E3%81%84%E3%81%84%E5%91%BD%E5%90%8D%E3%81%AF%E5%8F%AF%E8%AA%AD%E6%80%A7%E3%82%92%E9%AB%98%E3%82%81%E3%82%8B)
  - [文法](#%E6%96%87%E6%B3%95)
    - [名詞句](#%E5%90%8D%E8%A9%9E%E5%8F%A5)
    - [命令文](#%E5%91%BD%E4%BB%A4%E6%96%87)
  - [名前に統一性を持たせるためにルールを無視しない](#%E5%90%8D%E5%89%8D%E3%81%AB%E7%B5%B1%E4%B8%80%E6%80%A7%E3%82%92%E6%8C%81%E3%81%9F%E3%81%9B%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E3%83%AB%E3%83%BC%E3%83%AB%E3%82%92%E7%84%A1%E8%A6%96%E3%81%97%E3%81%AA%E3%81%84)
  - [引数名は誰に使われるかで命名されてはいけない](#%E5%BC%95%E6%95%B0%E5%90%8D%E3%81%AF%E8%AA%B0%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%82%8B%E3%81%8B%E3%81%A7%E5%91%BD%E5%90%8D%E3%81%95%E3%82%8C%E3%81%A6%E3%81%AF%E3%81%84%E3%81%91%E3%81%AA%E3%81%84)
  - [抽象処理は、どこで呼ばれるかで命名する](#%E6%8A%BD%E8%B1%A1%E5%87%A6%E7%90%86%E3%81%AF%E3%81%A9%E3%81%93%E3%81%A7%E5%91%BC%E3%81%B0%E3%82%8C%E3%82%8B%E3%81%8B%E3%81%A7%E5%91%BD%E5%90%8D%E3%81%99%E3%82%8B)
  - [曖昧性のない単語を選ぶ](#%E6%9B%96%E6%98%A7%E6%80%A7%E3%81%AE%E3%81%AA%E3%81%84%E5%8D%98%E8%AA%9E%E3%82%92%E9%81%B8%E3%81%B6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 可読性の重要性

開発中の多くの時間を「読む」ことに費やしている。  
コードを読む必要がある以上、可読性を向上させることが、生産性を改善する上で重要。

# 可読性が重要じゃない場合

ほとんど読まれないコードなら、重要ではない

- 試験的な実装
- すぐに捨てるスクリプト

# 可読性が重要な場合

どの程度、コードを長期に渡って残しておきたいかによる

- 他の開発者にコードを説明する
- コードを書いている最中に他のコードを参照する
- コードレビューを行う

# 土台が大事

長期間稼働するソフトウェアでは、コードの積み重ねが土台となって価値を創造していく。  
土台となるコードベースが安定し、理解しやすいことが成長を続ける鍵になる。  
土台がだめだとリソースを追加してもコストに見合った成果が出ない、このときソフトウェアは「飽和状態」にあるといえる。
飽和するポイントをを引き上げる方法の一つが「可読性の高いコードの維持」  
コードを書き上げた後に

- コメントを足す
- テストを追加する
- リファクタリング

など、継続して改善を行う

# 可読性と評価

評価が「機能の開発を期限内に行えたか」にすると、可読性の高いコードよりも、その場しのぎのコードを書くと評価が上がってしまう。  
囚人のジレンマ（お互い協力する方が協力しないよりもよい結果になることが分かっていても、協力しない者が利益を得る状況では互いに協力しなくなる）に陥る。

- どのようなコードを書いたか
- コードベースの改善にどれくらい協力的か
- チームの技術レベル向上への貢献

など多岐にわたる項目の評価を行うことが必要

## 可読性評価の指標

### 単純

コードが単純だと理解しやすい

### 意図が明確

命名が適切だと、機能の意図が明確で理解しやすい

### 独立性が高い

関数やクラス、モジュールなどのまとまりに気をつける

- それぞれのまとまりの責任範囲を明確にする
  - 関連性の薄いまとまりが混入しないようになる
- 他のまとまりとの依存関係を限定する
  - コードを理解するために読むべきコードの量を減らせられる
  - 相互依存は特に避けるべき。A<=>Bだと、AとBどっちのコードも見ないといけなくなるため

### 構造化されている

処理が長い場合はいくつかの補助的な関数に分解することで、構造化できる。  
インデントや改行も効果的。

## アーキテクチャやプログラミングテクニックを採用するときに重要なこと

コードや設計の品質向上のためにアーキテクチャやプログラミングテクニックを採用するのは有用。  
このとき、

- 採用する目的
  - なんのためにそのあーキテクチャやプログラミングテクニックを採用するのか
- 採用に適した条件
  - どういう環境でそれが有効に機能するのか

の２つを明確にする。以前では通用したアーキテクチャが、新しいパラダイムでは通用しないこともある。  
ここをおろそかにすると、かえってコードや設計の品質低下を招くこともある。

## 複雑性が増す事態をどう対処するか

新しい機能が増えるにつれてコードベースの複雑性は増す。  
複雑性の増加に伴って可読性は低下していく。  
価値の小さい機能だが複雑性は増加する機能の実装は拒否されるべき。  
同じ価値ならより単純な実装を選択するべき。

## 議論で本質的な問題について話す

設計や実装方針についてより良い結論に素早く到達するには他の字開発者と議論するのがいい。そのためにも、誰かに相談できる雰囲気作りが大事。  
表面的な議論（インデントはいくつかとか）は避け、本質的な問題に集中するようにすること。  
bike sheddingを避ける。

### bike shedding

自転車置き場については誰もが理解している（もしくは理解していると自分では思っている）ため、自転車置き場の設置については終わりのない議論が生じることになる。関係者の誰もが自分のアイデアを加えることによって自分の存在を誇示したがるのである。  
https://ja.wikipedia.org/wiki/%E3%83%91%E3%83%BC%E3%82%AD%E3%83%B3%E3%82%BD%E3%83%B3%E3%81%AE%E5%87%A1%E4%BF%97%E6%B3%95%E5%89%87

## KISS

Keep it simple stupid.

単純な実装であればあるほど機能実装が楽になる。自己満足のためにコードを複雑にするのは避けるべき。  
美しい、優雅なコードは可読性が高いとは限らないので、他人が読みやすい方を採用すること。

## 単一責任の原則

１つの処理に１つの責務だけ負わせること。変更箇所が少なくすむため。  
どのくらいの責務を持っているのか確認するために要約を書いてみるといい。整理しきれなければ責務が多いということになる。

> テストケースを書いてみると、同様にわかるかもしれない

# 命名

## いい命名は可読性を高める

命名が正確かつ説明的だとGood。  
「名前の示す意味と実態が一致している」「名前を見ただけでそれが何であるかが理解できる」だとOK。

## 文法

命名に際して、どの文型を用いるべきかは、命名する対象の種類によって決まる。  
基本的には、クラスや変数には名詞または名詞句、関数には命令文。

### 名詞句

「名前をつける対象が何であるかを示す単語」を最後に置く。

- buttonHeight
  - ボタンの高さ
- buttonHeightInPortraitMode
  - 縦画面モード時のボタンの高さ

inのような前置詞をつけるのは例外で、基本的には最後に単語を置く。

### 命令文

動詞の原形を先頭に置く。

## 名前に統一性を持たせるためにルールを無視しない

- UserEventClickText
- UserEventClickImage

のように、UserEventClickで揃えたいように、名前を美しさで決めてしまっては可読性に貢献できない。  
それを使ったコードが理解しやすいかを重要視すべき。

## 引数名は誰に使われるかで命名されてはいけない

誰に必要とされている値なのかで引数名を命名すると、その実装の詳細を読まなければいけなくなるので不適切。  
実装の詳細が変わったら引数の命名も変えなければいけなくなる。
その引数名が何に使われたい値かによって命名する。

## 抽象処理は、どこで呼ばれるかで命名する

何をするのか具体的に決まっていない関数などには「いつ・どこで呼ばれるのか」に基づいて命名する。  
onXXXなど。  
目的がはっきりしている抽象メソッドなら、「何をするのか」に基づいて命名する。

## 曖昧性のない単語を選ぶ
