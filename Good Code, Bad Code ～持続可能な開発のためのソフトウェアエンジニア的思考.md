# コードを書く際の 4 つのゴール

- 正しく動くこと
- 正しく動作し続けること
- 要件の変更に対応しやすいこと
  - どのように変化していくかはわからないが、変化するだろうということはわかっている
- 車輪の再開発をしないこと

# コード品質の柱

以下の柱を毎日のコーディングで意識する

- コードを読みやすくする
- 想定外の事態をなくす
- 誤用しにくいコードを書く
- コードをモジュール化する
- コードを再利用、汎用化しやすくする
- テストしやすいコードを書き、適切にテストする

# null 安全

処理が返す値が null である可能性を考慮し、null かどうかをチェックしなければ処理を利用できないようにするもの。  
コンパイラーが強制しているものがある。

# 抽象化レイヤー

大きな問題と小さな問題を解決するためには、一連のレイヤーの形成が必要。  
小さな問題を抽象化することで、いろいろな小さな問題をふんわりと概念として捉えることができる。  
抽象化された概念を抽象化レイヤーと呼ぶ。抽象化レイヤーと小さな問題を解決することで、より大きな問題を解決する。

抽象化レイヤーを作ると

- 読みやすさ
- モジュール性
- 再利用と汎用化
- テスタビリティ

を達成するのに役立つ。

- 関数
- クラス
- インターフェース
- パッケージ、名前空間、モジュール

といった単位でレイヤーは作る。

## 抽象化レイヤーの作り方

### API

API は機能の詳細を隠しているため、書いたコードが他のコードから呼び出されている形式は、API を呼び出していると考えていい。  
実装の詳細が漏れ出している API は、綺麗な抽象化ではないということ。

### 関数

責務の膨らんだ長いコードは理解しづらい。  
極端に言うと、1 処理 1 行で表現。

1 関数でできることを以下で制限：

- 単一のタスクをおこなう
- 適切な名前をつけた関数を呼び出して、より複雑な振る舞いを構成する

単一の責務を持つ処理として細かく分割することで、コードの可読性が高まり、再利用性が高まる。

長く読みづらいコードを書くのは簡単。

### クラス

書かないから詳細省く

### インターフェース

複数の実装の抽象化した機能の記述にちょうどいい。  
1 つの機能でしかそのインターフェースを使わない場合でも、インターフェースを使うことで

- パブリック API を明確化する
- 1 つの実装しか必要ないという予測が間違っている可能性がある
- テストしやすくなる
  - テスト時にインターフェースが必要な場合活用可能
- おなじクラスで２つの小さな問題を解決できる

デメリットも有る：

- 手間がかかる
- コードをより複雑にする

メリットが多い状況のときに利用するようにする。

## 抽象化レイヤーが薄い、厚い

薄すぎると不必要な複雑性をもたらし、厚すぎるとモジュール化されず、再利用性が低く読みにくくなる。  
ちょうどいいバランスは解決したい問題による。  
結局は自分自身で

- 読みやすさ
- モジュール性
- 再利用と汎用化
- テスタビリティ

を考えて適切な粒度を考えなければならない。

# 他のエンジニアと協同するときのコード

壊れやすいコードを混雑している（多くのエンジニアが触るため）コードベースに放置すると、すぐに壊れる。  
これを回避するには「堅牢」にする必要がある。

- あなたの明確は他者にとって明確ではない
  - あなたが時間をかけて考え上げた実装が、他者も時間をかけて理解できるとは限らない
- 他のエンジニアは不注意であなたのコードを壊す
  - あなたのコードの存在意義、用途を他のエンジニアが十分に理解できるとは限らない
- 自身で自身のコードを忘れる
  - 他人と未来の自分は同じカテゴリと考える

# コードを理解するために必要なこと

- どのようなシナリオで呼ばれるのか
- 何を表していて、いつ使われるのか
- どんな値を使って呼ぶべきか
- どういった動作をするのか
- どんな値を返すのか

# 他人がコードを理解するためにできること

これらは実践的なもの：

- 処理の名前
- 型
  - 引数
  - 戻り値
- ドキュメントや処理単位のコメント
  - ドキュメント
    - 実際に読まれる保証はない
    - 読まれた上で誤解される可能性がある
    - 情報が古くなる可能性がある

どうしようもないときにするもの：

- 作成者に尋ねる
- コードを読む

# 契約プログラミング

他のエンジニアにコードの使い方やどういう挙動が期待できるのかを伝える方法に関するいくつかの概念を形式化した原則。  
呼び出し元で特定の義務を果たすと、呼び出したコードは目的の値を返したり、いくつかの状態を変更する。

いくつか条件が存在する：

- 事前条件
  - 引数
  - インスタンス生成
- 事後条件
  - 戻り値
  - 副作用をもたらす処理
- 不変条件
  - コードでの呼び出し前後で比較した際に変わるべきではないもの

## 契約の細則は見ない

契約書のすべてを読むことが少ないように、契約プログラミングの細則をすべて読むことは少ない。

- 明確なもの
  - 関数、クラス名
  - 引数の型
  - 返却値の型
- 細則に紛れてしまい、軽視した結果不明瞭なもの
  - コメント
  - ドキュメント
  -

に分類される

## コメントは見られない

細かいコメントやドキュメントは見落とされやすい。  
詳細に書いたとしても見られない = コードの契約を伝えるのに信頼できない  
重要な情報はドキュメントやコメントに残すと効果はあるものの、見られない可能性があるので、これらを書かないよに実装を工夫する必要がある。

## コメントを消す方法

実装で間違ったことをできないように制御する。
露出したくない値を隠蔽する。
例えば、class の public, private。

# 検査

契約を強制させるために、 検査を行って、契約違反があればエラーをスローする。  
検査にはいくつかカテゴリがある

- 事前条件の検査
  - パラメータの正しさ
  - 初期化の実行
  - 期待したシステムの状態
- 事後条件の検査
  - 戻り値の正しさ
  - 期待していないシステムの状態

# アサーション

開発時にエラーや例外をスロ＝する機能を多くの言語は搭載している。  
production build 時には以下の理由から排除される。

- パフォーマンスの向上
  - 条件を満たすか処理が走ってしまうため
- コードの中断の可能性の削減

アサーションを production build 時にも有効にする方法もあり、多くの開発チームはそうしている。

# エラー

## 回復可能性

### 回復可能

多くのエラーは致命的ではない。  
正しく対処してエラーから回復してほしいケースがほとんど。

- フォームのバリデーション
- ネットワークエラー
- システムの外部が原因のエラー

### 回復不可能

エンジニアによるプログラミングエラーがほとんど。

- 関数の呼び出しが不適切
- コードがない

### 呼び出し元がエラーの種類を知る必要がある

対象の処理を実行し、それで生じたエラーが回復可能性かどうかを判断する必要がある。  
つまり、処理の作成者は、呼び出し元がエラーの種類を理解できるようにしなければならない。

##
