<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [コードを書く際の 4 つのゴール](#%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E9%9A%9B%E3%81%AE-4-%E3%81%A4%E3%81%AE%E3%82%B4%E3%83%BC%E3%83%AB)
- [コード品質の柱](#%E3%82%B3%E3%83%BC%E3%83%89%E5%93%81%E8%B3%AA%E3%81%AE%E6%9F%B1)
- [null 安全](#null-%E5%AE%89%E5%85%A8)
- [抽象化レイヤー](#%E6%8A%BD%E8%B1%A1%E5%8C%96%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC)
  - [抽象化レイヤーの作り方](#%E6%8A%BD%E8%B1%A1%E5%8C%96%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%AE%E4%BD%9C%E3%82%8A%E6%96%B9)
    - [API](#api)
    - [関数](#%E9%96%A2%E6%95%B0)
    - [クラス](#%E3%82%AF%E3%83%A9%E3%82%B9)
    - [インターフェース](#%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9)
  - [抽象化レイヤーが薄い、厚い](#%E6%8A%BD%E8%B1%A1%E5%8C%96%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%8C%E8%96%84%E3%81%84%E5%8E%9A%E3%81%84)
- [他のエンジニアと協同するときのコード](#%E4%BB%96%E3%81%AE%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%81%A8%E5%8D%94%E5%90%8C%E3%81%99%E3%82%8B%E3%81%A8%E3%81%8D%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89)
- [コードを理解するために必要なこと](#%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%81%93%E3%81%A8)
- [他人がコードを理解するためにできること](#%E4%BB%96%E4%BA%BA%E3%81%8C%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E7%90%86%E8%A7%A3%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8)
- [契約プログラミング](#%E5%A5%91%E7%B4%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)
  - [契約の細則は見ない](#%E5%A5%91%E7%B4%84%E3%81%AE%E7%B4%B0%E5%89%87%E3%81%AF%E8%A6%8B%E3%81%AA%E3%81%84)
  - [コメントは見られない](#%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AF%E8%A6%8B%E3%82%89%E3%82%8C%E3%81%AA%E3%81%84)
  - [コメントを消す方法](#%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E6%B6%88%E3%81%99%E6%96%B9%E6%B3%95)
- [検査](#%E6%A4%9C%E6%9F%BB)
- [アサーション](#%E3%82%A2%E3%82%B5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)
- [エラー](#%E3%82%A8%E3%83%A9%E3%83%BC)
  - [回復可能性](#%E5%9B%9E%E5%BE%A9%E5%8F%AF%E8%83%BD%E6%80%A7)
    - [回復可能](#%E5%9B%9E%E5%BE%A9%E5%8F%AF%E8%83%BD)
    - [回復不可能](#%E5%9B%9E%E5%BE%A9%E4%B8%8D%E5%8F%AF%E8%83%BD)
    - [呼び出し元がエラーの種類を知る必要がある](#%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E5%85%83%E3%81%8C%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AE%E7%A8%AE%E9%A1%9E%E3%82%92%E7%9F%A5%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B)
  - [エラー時の取り扱い 堅牢性 or 失敗](#%E3%82%A8%E3%83%A9%E3%83%BC%E6%99%82%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84-%E5%A0%85%E7%89%A2%E6%80%A7-or-%E5%A4%B1%E6%95%97)
    - [Fail fast](#fail-fast)
    - [Fail loudly](#fail-loudly)
    - [回復可能のエラーかどうか](#%E5%9B%9E%E5%BE%A9%E5%8F%AF%E8%83%BD%E3%81%AE%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B)
    - [エラーを隠すことによるリスク](#%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E9%9A%A0%E3%81%99%E3%81%93%E3%81%A8%E3%81%AB%E3%82%88%E3%82%8B%E3%83%AA%E3%82%B9%E3%82%AF)
  - [エラーの通知](#%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AE%E9%80%9A%E7%9F%A5)
    - [例外](#%E4%BE%8B%E5%A4%96)
      - [検査例外（主に Java） - 明示的](#%E6%A4%9C%E6%9F%BB%E4%BE%8B%E5%A4%96%E4%B8%BB%E3%81%AB-java---%E6%98%8E%E7%A4%BA%E7%9A%84)
      - [非検査例外 - 暗黙的](#%E9%9D%9E%E6%A4%9C%E6%9F%BB%E4%BE%8B%E5%A4%96---%E6%9A%97%E9%BB%99%E7%9A%84)
    - [null - 明示的](#null---%E6%98%8E%E7%A4%BA%E7%9A%84)
    - [Result 型 - 明示的](#result-%E5%9E%8B---%E6%98%8E%E7%A4%BA%E7%9A%84)
    - [エラーを示す戻り値 - 明示的](#%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E7%A4%BA%E3%81%99%E6%88%BB%E3%82%8A%E5%80%A4---%E6%98%8E%E7%A4%BA%E7%9A%84)
    - [Promise 型や Future 型 - 暗黙的](#promise-%E5%9E%8B%E3%82%84-future-%E5%9E%8B---%E6%9A%97%E9%BB%99%E7%9A%84)
  - [回復不可能なエラーを通知](#%E5%9B%9E%E5%BE%A9%E4%B8%8D%E5%8F%AF%E8%83%BD%E3%81%AA%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E9%80%9A%E7%9F%A5)
  - [回復したい可能性のあるエラーを通知](#%E5%9B%9E%E5%BE%A9%E3%81%97%E3%81%9F%E3%81%84%E5%8F%AF%E8%83%BD%E6%80%A7%E3%81%AE%E3%81%82%E3%82%8B%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E9%80%9A%E7%9F%A5)
    - [非検査例外を利用すべき派](#%E9%9D%9E%E6%A4%9C%E6%9F%BB%E4%BE%8B%E5%A4%96%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%81%B9%E3%81%8D%E6%B4%BE)
      - [エラーのロジックを上位の一部に委ねる](#%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AE%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%92%E4%B8%8A%E4%BD%8D%E3%81%AE%E4%B8%80%E9%83%A8%E3%81%AB%E5%A7%94%E3%81%AD%E3%82%8B)
      - [エンジニアの問題行動の抑制](#%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%81%AE%E5%95%8F%E9%A1%8C%E8%A1%8C%E5%8B%95%E3%81%AE%E6%8A%91%E5%88%B6)
    - [検査例外を利用すべき派](#%E6%A4%9C%E6%9F%BB%E4%BE%8B%E5%A4%96%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%81%B9%E3%81%8D%E6%B4%BE)
      - [エラーを見落とさない](#%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E8%A6%8B%E8%90%BD%E3%81%A8%E3%81%95%E3%81%AA%E3%81%84)
      - [エラー処理を適切に行う](#%E3%82%A8%E3%83%A9%E3%83%BC%E5%87%A6%E7%90%86%E3%82%92%E9%81%A9%E5%88%87%E3%81%AB%E8%A1%8C%E3%81%86)
      - [エンジニアの問題行動の抑制](#%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%81%AE%E5%95%8F%E9%A1%8C%E8%A1%8C%E5%8B%95%E3%81%AE%E6%8A%91%E5%88%B6-1)
  - [結局明示的な方がいい](#%E7%B5%90%E5%B1%80%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AA%E6%96%B9%E3%81%8C%E3%81%84%E3%81%84)
- [コメント](#%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88)
  - [冗長なコメントは有害](#%E5%86%97%E9%95%B7%E3%81%AA%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AF%E6%9C%89%E5%AE%B3)
  - [なぜこうなったのか理由のみ書く](#%E3%81%AA%E3%81%9C%E3%81%93%E3%81%86%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%8B%E7%90%86%E7%94%B1%E3%81%AE%E3%81%BF%E6%9B%B8%E3%81%8F)
- [コード](#%E3%82%B3%E3%83%BC%E3%83%89)
  - [行数にこだわらない](#%E8%A1%8C%E6%95%B0%E3%81%AB%E3%81%93%E3%81%A0%E3%82%8F%E3%82%89%E3%81%AA%E3%81%84)
  - [ネストは浅く](#%E3%83%8D%E3%82%B9%E3%83%88%E3%81%AF%E6%B5%85%E3%81%8F)
  - [関数の引数を読みやすくする](#%E9%96%A2%E6%95%B0%E3%81%AE%E5%BC%95%E6%95%B0%E3%82%92%E8%AA%AD%E3%81%BF%E3%82%84%E3%81%99%E3%81%8F%E3%81%99%E3%82%8B)
  - [値に説明をつける](#%E5%80%A4%E3%81%AB%E8%AA%AC%E6%98%8E%E3%82%92%E3%81%A4%E3%81%91%E3%82%8B)
- [マジックバリューを返さない - null,optional(undefined),error を返す](#%E3%83%9E%E3%82%B8%E3%83%83%E3%82%AF%E3%83%90%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%92%E8%BF%94%E3%81%95%E3%81%AA%E3%81%84---nulloptionalundefinederror-%E3%82%92%E8%BF%94%E3%81%99)
- [null オブジェクトパターン](#null-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)
  - [空のコレクションを返す](#%E7%A9%BA%E3%81%AE%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E8%BF%94%E3%81%99)
  - [空文字だと問題がある](#%E7%A9%BA%E6%96%87%E5%AD%97%E3%81%A0%E3%81%A8%E5%95%8F%E9%A1%8C%E3%81%8C%E3%81%82%E3%82%8B)
  - [null オブジェクトだと想定外の事態がおこることもある](#null-%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A0%E3%81%A8%E6%83%B3%E5%AE%9A%E5%A4%96%E3%81%AE%E4%BA%8B%E6%85%8B%E3%81%8C%E3%81%8A%E3%81%93%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E3%81%82%E3%82%8B)
- [関数の引数を null 許容にしない](#%E9%96%A2%E6%95%B0%E3%81%AE%E5%BC%95%E6%95%B0%E3%82%92-null-%E8%A8%B1%E5%AE%B9%E3%81%AB%E3%81%97%E3%81%AA%E3%81%84)
- [列挙型の取り扱い](#%E5%88%97%E6%8C%99%E5%9E%8B%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84)
  - [列挙型を使う場面](#%E5%88%97%E6%8C%99%E5%9E%8B%E3%82%92%E4%BD%BF%E3%81%86%E5%A0%B4%E9%9D%A2)
  - [追加される値を想定しない条件分岐にしてしまう - switch 文を使う](#%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%82%8B%E5%80%A4%E3%82%92%E6%83%B3%E5%AE%9A%E3%81%97%E3%81%AA%E3%81%84%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90%E3%81%AB%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%86---switch-%E6%96%87%E3%82%92%E4%BD%BF%E3%81%86)
  - [switch の default で error を throw しない（コンパイラーの特性による）](#switch-%E3%81%AE-default-%E3%81%A7-error-%E3%82%92-throw-%E3%81%97%E3%81%AA%E3%81%84%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%83%BC%E3%81%AE%E7%89%B9%E6%80%A7%E3%81%AB%E3%82%88%E3%82%8B)
- [テストでは想定外のことはカバーできない](#%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%81%AF%E6%83%B3%E5%AE%9A%E5%A4%96%E3%81%AE%E3%81%93%E3%81%A8%E3%81%AF%E3%82%AB%E3%83%90%E3%83%BC%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84)
- [契約プログラミングの契約の細則をどうにかする](#%E5%A5%91%E7%B4%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E5%A5%91%E7%B4%84%E3%81%AE%E7%B4%B0%E5%89%87%E3%82%92%E3%81%A9%E3%81%86%E3%81%AB%E3%81%8B%E3%81%99%E3%82%8B)
- [汎用的な型は使わない](#%E6%B1%8E%E7%94%A8%E7%9A%84%E3%81%AA%E5%9E%8B%E3%81%AF%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84)
- [モジュール化のメリット](#%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%8C%96%E3%81%AE%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88)
- [DI を念頭に設計するメリット](#di-%E3%82%92%E5%BF%B5%E9%A0%AD%E3%81%AB%E8%A8%AD%E8%A8%88%E3%81%99%E3%82%8B%E3%83%A1%E3%83%AA%E3%83%83%E3%83%88)
- [static cling - 静的粘着](#static-cling---%E9%9D%99%E7%9A%84%E7%B2%98%E7%9D%80)
- [DI 時のインターフェース](#di-%E6%99%82%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9)
- [継承の弱点と合成による対策](#%E7%B6%99%E6%89%BF%E3%81%AE%E5%BC%B1%E7%82%B9%E3%81%A8%E5%90%88%E6%88%90%E3%81%AB%E3%82%88%E3%82%8B%E5%AF%BE%E7%AD%96)
- [実装は自身に関心を持つべき](#%E5%AE%9F%E8%A3%85%E3%81%AF%E8%87%AA%E8%BA%AB%E3%81%AB%E9%96%A2%E5%BF%83%E3%82%92%E6%8C%81%E3%81%A4%E3%81%B9%E3%81%8D)
  - [デメテルの法則 - LoD](#%E3%83%87%E3%83%A1%E3%83%86%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87---lod)
- [想定](#%E6%83%B3%E5%AE%9A)
  - [早まった最適化](#%E6%97%A9%E3%81%BE%E3%81%A3%E3%81%9F%E6%9C%80%E9%81%A9%E5%8C%96)
  - [パフォーマンスコストを想定しない](#%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%82%B3%E3%82%B9%E3%83%88%E3%82%92%E6%83%B3%E5%AE%9A%E3%81%97%E3%81%AA%E3%81%84)
  - [想定をしたいなら強制させる](#%E6%83%B3%E5%AE%9A%E3%82%92%E3%81%97%E3%81%9F%E3%81%84%E3%81%AA%E3%82%89%E5%BC%B7%E5%88%B6%E3%81%95%E3%81%9B%E3%82%8B)
- [下位レイヤーの処理のデフォルト値](#%E4%B8%8B%E4%BD%8D%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%AE%E5%87%A6%E7%90%86%E3%81%AE%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E5%80%A4)
- [良いユニットテスト](#%E8%89%AF%E3%81%84%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88)
  - [コードの変更による破損を検出する](#%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E5%A4%89%E6%9B%B4%E3%81%AB%E3%82%88%E3%82%8B%E7%A0%B4%E6%90%8D%E3%82%92%E6%A4%9C%E5%87%BA%E3%81%99%E3%82%8B)
  - [Fleakey テストを避ける](#fleakey-%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E9%81%BF%E3%81%91%E3%82%8B)
  - [機能の変更とテスト](#%E6%A9%9F%E8%83%BD%E3%81%AE%E5%A4%89%E6%9B%B4%E3%81%A8%E3%83%86%E3%82%B9%E3%83%88)
  - [テストをわかりやすくする](#%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E3%82%8F%E3%81%8B%E3%82%8A%E3%82%84%E3%81%99%E3%81%8F%E3%81%99%E3%82%8B)
  - [テストのために詳細を公開しない](#%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AB%E8%A9%B3%E7%B4%B0%E3%82%92%E5%85%AC%E9%96%8B%E3%81%97%E3%81%AA%E3%81%84)
  - [実装が厚いとテストが大変なので分割する](#%E5%AE%9F%E8%A3%85%E3%81%8C%E5%8E%9A%E3%81%84%E3%81%A8%E3%83%86%E3%82%B9%E3%83%88%E3%81%8C%E5%A4%A7%E5%A4%89%E3%81%AA%E3%81%AE%E3%81%A7%E5%88%86%E5%89%B2%E3%81%99%E3%82%8B)
  - [共有した値をテストで利用しない](#%E5%85%B1%E6%9C%89%E3%81%97%E3%81%9F%E5%80%A4%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E5%88%A9%E7%94%A8%E3%81%97%E3%81%AA%E3%81%84)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# コードを書く際の 4 つのゴール

- 正しく動くこと
- 正しく動作し続けること
- 要件の変更に対応しやすいこと
  - どのように変化していくかはわからないが、変化するだろうということはわかっている
- 車輪の再開発をしないこと

# コード品質の柱

以下の柱を毎日のコーディングで意識する

- コードを読みやすくする
- 想定外の事態をなくす
- 誤用しにくいコードを書く
- コードをモジュール化する
- コードを再利用、汎用化しやすくする
- テストしやすいコードを書き、適切にテストする

# null 安全

処理が返す値が null である可能性を考慮し、null かどうかをチェックしなければ処理を利用できないようにするもの。  
コンパイラーが強制しているものがある。

# 抽象化レイヤー

大きな問題と小さな問題を解決するためには、一連のレイヤーの形成が必要。  
小さな問題を抽象化することで、いろいろな小さな問題をふんわりと概念として捉えることができる。  
抽象化された概念を抽象化レイヤーと呼ぶ。抽象化レイヤーと小さな問題を解決することで、より大きな問題を解決する。

抽象化レイヤーを作ると

- 読みやすさ
- モジュール性
- 再利用と汎用化
- テスタビリティ

を達成するのに役立つ。

- 関数
- クラス
- インターフェース
- パッケージ、名前空間、モジュール

といった単位でレイヤーは作る。

## 抽象化レイヤーの作り方

### API

API は機能の詳細を隠しているため、書いたコードが他のコードから呼び出されている形式は、API を呼び出していると考えていい。  
実装の詳細が漏れ出している API は、綺麗な抽象化ではないということ。

### 関数

責務の膨らんだ長いコードは理解しづらい。  
極端に言うと、1 処理 1 行で表現。

1 関数でできることを以下で制限：

- 単一のタスクをおこなう
- 適切な名前をつけた関数を呼び出して、より複雑な振る舞いを構成する

単一の責務を持つ処理として細かく分割することで、コードの可読性が高まり、再利用性が高まる。

長く読みづらいコードを書くのは簡単。

### クラス

書かないから詳細省く

### インターフェース

複数の実装の抽象化した機能の記述にちょうどいい。  
1 つの機能でしかそのインターフェースを使わない場合でも、インターフェースを使うことで

- パブリック API を明確化する
- 1 つの実装しか必要ないという予測が間違っている可能性がある
- テストしやすくなる
  - テスト時にインターフェースが必要な場合活用可能
- おなじクラスで２つの小さな問題を解決できる

デメリットも有る：

- 手間がかかる
- コードをより複雑にする

メリットが多い状況のときに利用するようにする。

## 抽象化レイヤーが薄い、厚い

薄すぎると不必要な複雑性をもたらし、厚すぎるとモジュール化されず、再利用性が低く読みにくくなる。  
ちょうどいいバランスは解決したい問題による。  
結局は自分自身で

- 読みやすさ
- モジュール性
- 再利用と汎用化
- テスタビリティ

を考えて適切な粒度を考えなければならない。

# 他のエンジニアと協同するときのコード

壊れやすいコードを混雑している（多くのエンジニアが触るため）コードベースに放置すると、すぐに壊れる。  
これを回避するには「堅牢」にする必要がある。

- あなたの明確は他者にとって明確ではない
  - あなたが時間をかけて考え上げた実装が、他者も時間をかけて理解できるとは限らない
- 他のエンジニアは不注意であなたのコードを壊す
  - あなたのコードの存在意義、用途を他のエンジニアが十分に理解できるとは限らない
- 自身で自身のコードを忘れる
  - 他人と未来の自分は同じカテゴリと考える

# コードを理解するために必要なこと

- どのようなシナリオで呼ばれるのか
- 何を表していて、いつ使われるのか
- どんな値を使って呼ぶべきか
- どういった動作をするのか
- どんな値を返すのか

# 他人がコードを理解するためにできること

これらは実践的なもの：

- 処理の名前
- 型
  - 引数
  - 戻り値
- ドキュメントや処理単位のコメント
  - ドキュメント
    - 実際に読まれる保証はない
    - 読まれた上で誤解される可能性がある
    - 情報が古くなる可能性がある

どうしようもないときにするもの：

- 作成者に尋ねる
- コードを読む

# 契約プログラミング

他のエンジニアにコードの使い方やどういう挙動が期待できるのかを伝える方法に関するいくつかの概念を形式化した原則。  
呼び出し元で特定の義務を果たすと、呼び出したコードは目的の値を返したり、いくつかの状態を変更する。

いくつか条件が存在する：

- 事前条件
  - 引数
  - インスタンス生成
- 事後条件
  - 戻り値
  - 副作用をもたらす処理
- 不変条件
  - コードでの呼び出し前後で比較した際に変わるべきではないもの

## 契約の細則は見ない

契約書のすべてを読むことが少ないように、契約プログラミングの細則をすべて読むことは少ない。

- 明確なもの
  - 関数、クラス名
  - 引数の型
  - 返却値の型
- 細則に紛れてしまい、軽視した結果不明瞭なもの
  - コメント
  - ドキュメント
  -

に分類される

## コメントは見られない

細かいコメントやドキュメントは見落とされやすい。  
詳細に書いたとしても見られない = コードの契約を伝えるのに信頼できない  
重要な情報はドキュメントやコメントに残すと効果はあるものの、見られない可能性があるので、これらを書かないよに実装を工夫する必要がある。

## コメントを消す方法

実装で間違ったことをできないように制御する。
露出したくない値を隠蔽する。
例えば、class の public, private。

# 検査

契約を強制させるために、 検査を行って、契約違反があればエラーをスローする。  
検査にはいくつかカテゴリがある

- 事前条件の検査
  - パラメータの正しさ
  - 初期化の実行
  - 期待したシステムの状態
- 事後条件の検査
  - 戻り値の正しさ
  - 期待していないシステムの状態

# アサーション

開発時にエラーや例外をスロ＝する機能を多くの言語は搭載している。  
production build 時には以下の理由から排除される。

- パフォーマンスの向上
  - 条件を満たすか処理が走ってしまうため
- コードの中断の可能性の削減

アサーションを production build 時にも有効にする方法もあり、多くの開発チームはそうしている。

# エラー

## 回復可能性

### 回復可能

多くのエラーは致命的ではない。  
正しく対処してエラーから回復してほしいケースがほとんど。

- フォームのバリデーション
- ネットワークエラー
- システムの外部が原因のエラー

### 回復不可能

エンジニアによるプログラミングエラーがほとんど。

- 関数の呼び出しが不適切
- コードがない

### 呼び出し元がエラーの種類を知る必要がある

対象の処理を実行し、それで生じたエラーが回復可能性かどうかを判断する必要がある。  
つまり、処理の作成者は、呼び出し元がエラーの種類を理解できるようにしなければならない。

## エラー時の取り扱い 堅牢性 or 失敗

- エラーを処理して、アプリケーションを継続させる
- エラー時にクラッシュさせて、アプリケーションを停止させる

動作を続けるか、アプリケーションを停止するのかの基準を決める必要がある。

### Fail fast

Fail fast だと、メリットが大きい。  
回復可能なエラーだと、エラーから適切に安全に回復できる可能性を最大化する。  
回復不可能だと、エンジニアの問題特定かつ修正の可能性を最大化する。  
よって、早く失敗してエラーをスローすることが大事。

### Fail loudly

エラーというものは誰も望んでいない。  
発生すれば修正したいものであるが、バグに気がつく必要がある。  
エラーは目立つようにして、見逃さないようにする。  
目立てばバグの発見確率が上がる。エラーレポートのログがたまり、エラー発生箇所を特定しやすくなる。

### 回復可能のエラーかどうか

エラーは目立つべきだが、目立つためにはアプリケーションをクラッシュするレベルになる。しかしそうすると堅牢性を損ない、回復ができない。  
エラーが発生したら、エラーをロギングして確実に補足しつつ、エラーハンドリングを行い復帰する。

### エラーを隠すことによるリスク

エラーを下位レイヤーでキャッチし、それを無視してアプリケーションを動かすと適切なエラーハンドリングできているとは言えず、適切な動きを保証できない。

以下のように握りつぶすことができるがおすすめしない。

- デフォルト値を返す
- 何もしない
  - return するだけ

## エラーの通知

エラーは上位レイヤーにハンドリングしてもらいたいので、エラーを上位レイヤーに通知する必要がある。  
通常は最も上位レイヤーのプログラムで処理を中断してエラーをログに送信するか、プログラムを終了する。  
エラーの通知は２つに分類できる

- 明示的
  - 呼び出し元にエラーが起こる可能性を意識させる
  - エラーをどう取り扱うのかは呼び出し元に委ねる
  - エラー処理を忘れる可能性はほぼない
- 暗黙的
  - エラーが発生しても呼び出し元が気にすることはない
  - エラーが起こるかはコードについて知る必要がある

エラーを意識する必要があるシナリオでは「明示的」、呼び出し元が適切にエラーを処理しなくていい、できないシナリオでは「暗黙的」を使う。

### 例外

投げられたエラーを特に処理しなければアプリケーションは終了する。  
例外には２つの概念がある

#### 検査例外（主に Java） - 明示的

- コードに例外処理を書かせる
- 明示的にエラーを通知する
- 例外投げるよーと型を付けたなら、それを呼び出すもとでは try catch でエラーを処理しなければコンパイルできない

#### 非検査例外 - 暗黙的

- 例外を投げることをどこにも知らせない
- 暗黙的にエラーを通知する
- キャッチされなかったエラーはプログラムを終了させる

### null - 明示的

値を返せなかったことを示すことができる。つまり、通常処理できなかった場合の返却値として利用できる。  
返した null が何を示しているのかを気をつける必要がある。

- なにか意味があって null を返している
- エラー時の返却値として null を返している

### Result 型 - 明示的

Swift,Rust,F#などで組み込まれているもの。
TS だとこんな感じ https://gist.github.com/tyankatsu0105/5acb2244913bb9cc09afe8a6fc076134
「返却値にはエラー時に返したい値が存在していること」を示すために使う。

### エラーを示す戻り値 - 明示的

boolean や enum など、エラーを示す戻り値を返すことでエラーを通知する。

### Promise 型や Future 型 - 暗黙的

エラーを伝えられる。  
発生したエラーの取り扱いを強制しないため、暗黙的。  
明示的にするのなら、Promise の返却値に Result 型を使うが、コードが複雑になるためおすすめしない。

## 回復不可能なエラーを通知

エラーから回復する手段が思いつかないなら、暗黙的なエラーは理にかなっている。
エラーから回復する手段が思いつかないときは、

- 非検査例外をスロー
- panic を実行
- 検査やアサーションを使う

などで Fail loudly する。

## 回復したい可能性のあるエラーを通知

検査例外を利用すべき派と非検査例外を利用すべき派で別れている。

### 非検査例外を利用すべき派

#### エラーのロジックを上位の一部に委ねる

エラーは処理されなければ上に伝搬していくため、必要ならば必要なタイミングでエラーを処理すればいい。  
いたるところにエラーの処理を書かなくていいので、コードがシンプルになる。

#### エンジニアの問題行動の抑制

エラー処理のために明示的なエラーハンドリングを書かなければならないようになると、キャッチしたエラーを握りつぶすなど、エラーを隠して面倒事を避けるようになる。  
暗黙的だとそのような心配はない。

### 検査例外を利用すべき派

#### エラーを見落とさない

エラーを処理しないと適切な処理を行えないため、エラーを見落とすことはない。これはレビュー時にも役に立つ。  
呼び出し元によってはエラーを必ず処理しなければならないため、間違いを犯すこともない。

#### エラー処理を適切に行う

エラーを処理すべきところでエラーを処理できず、ほかの箇所に影響を与えることがない。  
エラーメッセージを出すべきところで出さない、出したとしても予期しないエラーメッセージが出るなど。

#### エンジニアの問題行動の抑制

どこから非検査例外が投げられるか把握できない。そのためあらゆるエラーをキャッチして処理するようになる。本来は回復不可能なエラーもハンドリングしてしまう。

## 結局明示的な方がいい

非検査例外が十分にドキュメントされ、エラーのことを記述されていることは少ない。  
エンジニアがエラーに気がつけていれば回復できていたケースが多数ある。  
非検査例外を使うデメリットが、検査例外を使うデメリットを上回る。  
プロジェクトに携わるエンジニア内で合意を取り、同じアプローチで例外処理を行うことが大切。

# コメント

## 冗長なコメントは有害

実装と一緒にコメントを変更する必要が出る。命名を変えたり説明変数や関数分割など、自明な処理によってコメントは削減可能。

## なぜこうなったのか理由のみ書く

コードが自明にしづらい、なぜその処理が必要なのかをコメントするべき。

# コード

## 行数にこだわらない

- わかりやすい
- 誤解されない
- 壊れにくい

これが担保できれば、行数は関係ない。短いと良いということもない。  
長すぎると何かを過度に複雑にしていたり、既存の処理の再利用をしていなかったりすることがあるので注意する。

## ネストは浅く

if や for など、文のブロックは深くなると読みやすさが低下する。  
条件分岐が多すぎると、責務が多すぎる可能性がある。その場合は小さな関数に処理を分割する。

## 関数の引数を読みやすくする

引数が多いと関数呼び出しは読みにくくなる。
名前付き引数を使って引数の意味を明確にする。

```ts
sendMessage("hello", 1, true);
// ↓
sendMessage({ message: "hello", priority: 1, allowRetry: true });
```

## 値に説明をつける

マジックナンバーや固定文字列といった、値に意味がある場合は定数にして、その定数に説明をつける。

# マジックバリューを返さない - null,optional(undefined),error を返す

エラー時に関数が返す値を-1 とする習慣が昔あった。明示的なエラーを返したり、null を返すことができたとは限らなかったから。  
値が存在していないことを示すために null を返せるようにし返す。または undefined を返す。

# null オブジェクトパターン

null を返すかわりに、下流のロジックに影響を与えない値を返す。null 安全でない言語だと有用。

## 空のコレクションを返す

コレクションを返す場合、空のコレクションを返す。null を返すと呼び出し元で null かどうかのチェックが必要になる。

## 空文字だと問題がある

空のコレクションとは違って、空文字を返すと不都合がおこるときがある。  
何らかの文字列を返すことを期待しているとき、空文字を返すことで、null のように文字情報がないことを示せる。  
逆に、なんらかの文字列を返すことを期待した処理が下流で発生するとき、空文字だとエラーのもとになりうる。この場合は null を返すべき。

## null オブジェクトだと想定外の事態がおこることもある

null ではない = 値が存在している　と勘違いした実装者が、使い方を間違えて条件分岐を間違えた結果、処理が間違っているということもある。  
現在は null やオプショナルが簡単かつ安全なので、null オブジェクトよりもそっちを使ったほうがいい。

# 関数の引数を null 許容にしない

引数が null の場合に何もしない関数ということを、読み落とす場合がある。  
それだったら、null を許容しないようにしたほうが誤解を招かないで済む。

# 列挙型の取り扱い

## 列挙型を使う場面

- 誰かが列挙型を使っていて、処理にその列挙型を使うことを余儀なくされている場合
- 別のシステムのアウトプットの信頼できるソースとして列挙型を利用している場面

列挙型を使う場合、新しい値が追加されることを考慮した実装にすること。そうしないと想定外の事態を起こすこともある。

## 追加される値を想定しない条件分岐にしてしまう - switch 文を使う

```ts
enum Blood {
  A,
  B,
}

const someFn = (blood: Blood) => {
  if (blood === Blood.A) {
    return "A型です";
  }

  return "B型です";
};
```

ここで Blood に AB が追加されると、条件に引っかからずに`B型です`と返される。このように、列挙型を使う場合は、追加される値を想定した処理を書く必要がある。  
列挙型全ケースを考慮しないとエラーを吐くような、switch とかの処理だと安全性が増す。[TS での例](https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhhCBTATlAckgbqmBeGACgBM4o4AuGMbVASnwD4YBvAXwCgOkwBXAWxgAhADYgQxVhxgwAggBppwxTNlCOnDqEiwIIfkgBiYfEQBGYiVVHjiDPMxZKIAdwCWUYAAtCF2wycZGWAEJGFLYgA6WQolIJgUJCheFBMAIllAaPVAcwZATQY0uJgQ5HDbSKFY+JlE5NSYNKEc-MKAehai0NKJaIrW9uqklPS1JoL44iQAMzheEShKqoRkNEwcFF8IukKZNqq9gD0Afm2Ewbq0sZhONiA)
switch を使う場合、default があるので、暗黙的な処理に注意する。

## switch の default で error を throw しない（コンパイラーの特性による）

コンパイラーによっては、switch のケースをすべて通っていないとコンパイル時に警告を出す。  
これが default があるとそれが機能しなくなる。  
default を書かずに、switch の文の後にエラーを投げると良い。

> TS では、switch のケースをすべてかけていなくても警告を出さない。よって、このパターンは TS では使えない。

# テストでは想定外のことはカバーできない

- テストに熱心ではない開発者がいると不安要素高まる
- テストで全パターン考慮できていない場合が存在してしまう
- テストが難しい実装があると、テストケースが存在しないケースが発生してしまう

テストは重要だが、テストだけでは不安要素をすべてカバーできない。

# 契約プログラミングの契約の細則をどうにかする

契約の細則は以下のようなもの

- 引数に渡した値を変更する
- 不正な値を引数に渡す
- 呼び出し元が「正しいタイミング」で「正しい順序」で関数を呼び出していない
- 想定を外れる変更を関連コードの一部に加える

細則をどうにかし、「誤用しにくい」設計が大事。

# 汎用的な型は使わない

```ts
const getUser = (id: string): Record<string, string> => {
  // ...
};
```

よりも

```ts
type ID = string;
type Name = string;
type User = Record<ID, Name>;

const getUser = (id: string): User => {
  // ...
};
```

のように型に命名したほうが誤用されにくい。

# モジュール化のメリット

モジュール化した機能はそれぞれが自己完結しているので、要件の変更に対応、機能の再構築が容易になる。  
再利用しやすい。テストしやすいので機能の担保が容易。

# DI を念頭に設計するメリット

機能 A が機能 B に依存している場合、
メリット

- 機能 A は利用するのが用意になる

デメリット

- 機能 B の実装の変更に機能 A が引きずられる
- 機能 B の代替機能を使いたい場合、機能 A の実装を変更する必要がある

というメリデメが発生する。  
そのため、DI という考え方で引数やコンストラクタに値を挿入することで、機能の詳細を外部機能に委譲できる。

# static cling - 静的粘着

class の static method のような静的関数に過度に依存すること

# DI 時のインターフェース

DI に利用する別モジュールは、全て同じ機能を実装していることを前提としていなければ代替にならない。そのためインターフェースを利用して、同じ機能を実装していることを保証する必要がある。

# 継承の弱点と合成による対策

継承を行うといくつかのデメリットが顕在化する

- 継承元（スーパークラス）の API を継承先（サブクラス）が利用することで、スーパークラスでは内部処理にとどめていた機能がサブクラスで公開されてしまう
  - サブクラスによって公開 API になってしまい、機能の変更が難しくなる
- 継承が重なると、コードを複製する頻度が増える

これを合成（コンポジション）によって解決する

- インスタンスを生成し。コンストラクタでインスタンスを受け取ることで、外部からインスタンスを注入する
  - 合成先が機能を公開していない限り、合成元でその機能を使えなくなり、機能が限定的に閉じるため機能の変更が容易になる

# 実装は自身に関心を持つべき

使われる先の機能に関心を持つとモジュール性が低下する。使われる先の機能の変更に追従できなければ機能は壊れる。  
自身のみに関心を持った機能を作ることで、機能の変更に強いモジュールを作ることができる。

## デメテルの法則 - LoD

あるオブジェクトが他のオブジェクトの内容や構造について持っている前提を最小限にするべきという原則。

# 想定

機能開発時には、一定の想定の元コードを変更すると、効率的にもなるし脆く汎用性の低いものにもなる。想定をコードに導入するときにはメリット・デメリットを検討する必要がある。コードの変更で享受できる効果が少ないと、かえって脆いものになる。

## 早まった最適化

コードの最適化にはコストが伴う。多くの場合、最適化を行ったコードは読みにくく保守しづらく堅牢性も低い。最適化とはコードの一部を何千回も何百万回も実行するとはっきりと分かるメリットである。よって、ほとんどの場合パフォーマンスよりも読みやすく保守しやすく堅牢性を高めた方がいい。最適化のメリットが顕在化してきたらそのとき最適化を行った方がいい。

## パフォーマンスコストを想定しない

パフォーマンスを気にして想定をコードに埋め込むと、コードが複雑になり保守性が低下する。  
例）記事中の画像を取得する処理 `getAllImage`は、パフォーマンスコストを想定して、記事中に画像が１枚しかない想定で作られている。これは処理名の「すべての画像を取得できる」ような命名とは相反するし、使われる側で縛りを発生させている。このようにパフォーマンスコストを気にした実装は、メリットよりも実装コストが上回る可能性が高い。パフォーマンスコストを気にした実装よりも、バグのもとになる実装をなるべく避けるべき。

## 想定をしたいなら強制させる

- 想定が崩れないようにする
  - 想定外の場合はコンパイルできないようにして、想定が崩れないようにする
- エラー通知をする
  - 想定外のときにコンパイルエラーにできなければ、呼び出し元でエラーを通知して早く失敗させる

# 下位レイヤーの処理のデフォルト値

下位レイヤーでの処理がデフォルト値を提供すると、上位レイヤーでそのデフォルト値の取り扱いを強制されてしまう。  
一般的に下位レイヤーでは汎用性を求められるので、上位レイヤーのユースケース全ての理にかなっているデフォルト値を提供するのは非常に難しい。

そこで２つの方法を組み合わせるといい

- null を返す
  - あらゆる上位レイヤーの要望を叶えられる初期値を提供するのが難しいのであれば、null を返す。
- 上位レイヤーで注入する
  - 下位レイヤーを扱う上位レイヤーで下位レイヤーの処理のデフォルト値を注入できるようにすると、デフォルト値に関する実装の詳細を上位レイヤーに委ねられる。

下位レイヤーでは単純に null を返して、上位レイヤーでデフォルト値を設定できるように処理を作るといい。

# 良いユニットテスト

- 破損を正確に検出する
  - 本当に壊れている場合のみ失敗する
- 実装の詳細にとらわれない
  - 実装の詳細を変更してもテストに手は加えなくてもいい状態
- よく説明された失敗
  - テストの失敗は問題の明確な説明を提供する
- わかりやすいテストコード
  - 他のエンジニアがテストコードを見て何をどのようにテストをしているのか理解できる
- 簡単かつ迅速に実行する
  - 開発時間を確保するために早く、実行が容易

## コードの変更による破損を検出する

コードベースは頻繁に変更され、うっかりコードを壊した場合、テストがそれを検出するべきである。  
コードの変更によって壊れた機能を「リグレッションテスト」と呼ぶ。リグレッションを検出するリグレッションテストと呼ぶ

## Fleakey テストを避ける

テストが正常であっても pass, fail がランダムになるテストを「Fleakey テスト」と呼ぶ。

## 機能の変更とテスト

機能に変更を加えるタイミングは大きく２つある

- 機能変更
- リファクタリング

機能変更時はテストも変更する必要がある。  
リファクタリング時はテストは変更しない。テストを変更しないといけないときは実装が変わっている時なので良くない。

詳細をテストしすぎると、少しの内部処理の変更でテストが失敗する。そうなるとリファクタで実装を間違えたのか確証が持てなくなる。

## テストをわかりやすくする

コードの変更と、そのコードのテスト箇所は一緒に変更されるはず。つまり、変更されていない箇所のテストは変更しないはず。

- 一度に多くのことをテストする
- 多くの共有されたテストのセットアップを利用する

これらは理解と予測がしにくいテストに繋がる可能性がある。

##　パブリックな実装以外もテストする必要

詳細をテストするとテストが壊れやすいので、なるべくパブリックな機能のみをテストする。  
しかし、重要な動作がパブリックな機能以外にもある場合がある。

- サーバーとのやりとり
- データベースの値を読み書きする

パブリックな機能に副作用がある場合は、テストをパブリックな機能に限定しない。

## テストのために詳細を公開しない

パブリックな機能の詳細をテストしても、テストが壊れやすくなるのみ。  
実際はパブリックな機能を用いて機能が作られていくので、パブリックな機能が期待した動作をしているのかをテストするべき。

## 実装が厚いとテストが大変なので分割する

パブリックな機能が厚いと、テストが大変になる。そのため、パブリックな機能を小さく分割し、その単位でテストをする。  
問題は小さな単位で取り扱い、テストをしやすくしていくと良い。

## 共有した値をテストで利用しない

テストコード内で重複した値を

- beforeAll
- beforeEach
  のようなセットアップで共有すると、テストが壊れやすくなる。  
  3 つのテストで依存していた共通の値をセットアップで作成し、後に 4 つ、5 つとテストが増えていくと、共通の値によってテストが失敗する事態が発生しやすくなる。  
  どのテストがどのような値を利用しているのかを把握するのが難しくなるため、通常はテストコード内で共有した値を利用しない。  
  重複した値をテストケース内で定義したほうが、面倒ではあるが安全になる。面倒であればヘルパー関数のようなものを作成するといい。テストの外側でテストを壊すことを防ぐ。
