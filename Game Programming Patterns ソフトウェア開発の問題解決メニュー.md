<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents** _generated with [DocToc](https://github.com/thlorenz/doctoc)_

- [いいデザイン](#%E3%81%84%E3%81%84%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3)
- [プログラミングフロー](#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%83%95%E3%83%AD%E3%83%BC)
- [よいアーキテクチャの豊漁発揮のタイミング](#%E3%82%88%E3%81%84%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E8%B1%8A%E6%BC%81%E7%99%BA%E6%8F%AE%E3%81%AE%E3%82%BF%E3%82%A4%E3%83%9F%E3%83%B3%E3%82%B0)
- [分離](#%E5%88%86%E9%9B%A2)
- [ソフトウェアアーキテクチャと抽象化 vs 実行速度](#%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%A8%E6%8A%BD%E8%B1%A1%E5%8C%96-vs-%E5%AE%9F%E8%A1%8C%E9%80%9F%E5%BA%A6)
- [プロトタイプを作成する時期のなぐり書きコード](#%E3%83%97%E3%83%AD%E3%83%88%E3%82%BF%E3%82%A4%E3%83%97%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E6%99%82%E6%9C%9F%E3%81%AE%E3%81%AA%E3%81%90%E3%82%8A%E6%9B%B8%E3%81%8D%E3%82%B3%E3%83%BC%E3%83%89)
- [3 つの目標のトレードオフ](#3-%E3%81%A4%E3%81%AE%E7%9B%AE%E6%A8%99%E3%81%AE%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95)
- [コマンド](#%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89)
- [フライウェイト](#%E3%83%95%E3%83%A9%E3%82%A4%E3%82%A6%E3%82%A7%E3%82%A4%E3%83%88)
- [オブザーバー](#%E3%82%AA%E3%83%96%E3%82%B6%E3%83%BC%E3%83%90%E3%83%BC)
  - [処理速度がおそすぎる](#%E5%87%A6%E7%90%86%E9%80%9F%E5%BA%A6%E3%81%8C%E3%81%8A%E3%81%9D%E3%81%99%E3%81%8E%E3%82%8B)
- [プロトタイプ](#%E3%83%97%E3%83%AD%E3%83%88%E3%82%BF%E3%82%A4%E3%83%97)
- [シングルトン](#%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%AB%E3%83%88%E3%83%B3)
- [ステート](#%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88)
  - [FSM 有限状態機械](#fsm-%E6%9C%89%E9%99%90%E7%8A%B6%E6%85%8B%E6%A9%9F%E6%A2%B0)
  - [並行状態機械](#%E4%B8%A6%E8%A1%8C%E7%8A%B6%E6%85%8B%E6%A9%9F%E6%A2%B0)
  - [階層的状態機械](#%E9%9A%8E%E5%B1%A4%E7%9A%84%E7%8A%B6%E6%85%8B%E6%A9%9F%E6%A2%B0)
  - [プッシュダウンオートマトン](#%E3%83%97%E3%83%83%E3%82%B7%E3%83%A5%E3%83%80%E3%82%A6%E3%83%B3%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3)
- [ダブルバッファ](#%E3%83%80%E3%83%96%E3%83%AB%E3%83%90%E3%83%83%E3%83%95%E3%82%A1)
- [型オブジェクト](#%E5%9E%8B%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88)
- [サービスロケータ](#%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%AD%E3%82%B1%E3%83%BC%E3%82%BF)
- [dirty flag](#dirty-flag)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## いいデザイン

何かを変更したときに、プログラム全体がその変更を予期していたように作られている設計  
変更を容易にするもの

## プログラミングフロー

1. 問題発見
   - 機能を試して改良の余地や、不具合を発見する
2. コードの熟読
   - 今あるコードを読む
   - 何をしているのかの把握
3. 解決策のコード化
   - 解法をコードに書き起こす
   - 試行錯誤を繰り返す
   - 比較的簡単なこともある
4. 後片付け
   - テストを作成
   - 試行錯誤のために仕込んだログの削除

## よいアーキテクチャの豊漁発揮のタイミング

コードを読んで理解するとき  
分離できていない（結合している） = 一方を理解していないともう一方が理解できない  
分離ができていると変更が全体に及ぼす影響は少ない  
次に進む前に頭に入れておかなければならない知識を最小にすること

## 分離

抽象化、モジュール化、デザインパターン、ソフトウェアアーキテクチャといったものにこだわると、いい分離ができるようになる  
しかしちゃんと学ばないと、過度に複雑化していく

## ソフトウェアアーキテクチャと抽象化 vs 実行速度

開発効率のためのアーキテクチャと引き換えに、ある程度の実行コストが発生する  
しかし、開発効率を上げてアプリケーションの実装スピードを上げた文だけアプリケーションの機能開発に時間を割けられる  
開発効率を上げてアプリケーションに十分な機能を作れてきたら、実行速度を高めるためにいくつかの抽象化を取り除いていったほうが効率的

## プロトタイプを作成する時期のなぐり書きコード

プロトタイプを作成する時期は、アプリケーションが市場で通用するか検証をするタイミング  
このときにアーキテクチャを考えて整ったコードを書くのは一種の賭け  
捨てる確率が高いので、無意味なアーキテクチャになる可能性がある  
そのため、なぐり書きコードを書くことが多い
しかし、そのプロトタイプをそのまま市場に出すこともある。そのときなぐり書きコードをそのままメンテナンスしなければならなくなり、首を締めることに成る

## 3 つの目標のトレードオフ

- プロジェクトが生きている間はコードが読みやすくなければならないので、整ったアーキテクチャが維持される。
- 実行速度が速い。
- 今日見い出された問題にできるだけ短期間で答えを出せる。

機能開発は 3 つの目標のトレードオフの繰り返し  
プロジェクトで最適な距離感を見つけることが重要

## コマンド

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#command
undo redo のように状態が必要になるときがあるが、JS のようにクロージャーがあれば、クラス以外に関数でもかける。

## フライウェイト

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#flyweight
最低限共通化してもいいモデルを一個生成して、それを複数のインスタンス化する際に流用する  
オブジェクトの軽量化を担う

- intrinsic
  - すべてのインスタンスで共有できるモデル
- extrinsic
  - インスタンス固有のもの

の２つで構成

## オブザーバー

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#observer

特定のイベントを発生するサブジェクトが、リスト登録されたオブジェクト（オブザーバ）に変更を通知する  
それぞれのオブザーバは独立しているので、１つのイベントで複数のオブザーバに通知することができる  
サブジェクトはオブザーバに「通知する」役割があるので、そのタイミングで各オブザーバが処理を実行できる  
サブジェクトとオブザーバは密に結合していないが間接的につながっているので結合度を下げることができる

オブザーバには意見がある

### 処理速度がおそすぎる

「キューイング」や「動的確保」といった意図的に遅くしているものがある

## プロトタイプ

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#prototype

JSON のように、共通のプロパティを含むが、一部違うようなオブジェクトを定義するなら、基底クラスを作って、それを継承するかミックスインとして使うとコード量が減る

## シングルトン

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#singleton

クラスにカプセル化したグローバル変数なので、使わないほうがいい  
アクセス性が良くなるだけだが、メリットはそれ以外ない

## ステート

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#state

### FSM 有限状態機械

計算機科学のオートマトン理論分野から生まれた「状態」と「遷移」の概念を用いたモデル

- 可能な状態の集合がある
  - 食べる、飲む、寝る、起きる
- 一度に１つの状態になる
  - 食べる状態になると、飲む状態にはなれない
- 一連のイベント、入力が与えられる
- とある状態で一連の入力があれば、決まった状態へ遷移する
  - 「寝る」状態で「8 時間経過」というイベントで「起きる」状態へ遷移する

状態機械は、扱いにくい問題に対して非常に制限的な構造を強制することでわかりやすくするのを助ける一方で、複雑なことをやるには扱いにくい

### 並行状態機械

X しながら Y するというように、２つの状態を持ちたいとき、１つの状態機械では表現できない  
そこで２つの状態機械を並行させることで表現する

### 階層的状態機械

よくわからん

### プッシュダウンオートマトン

状態のスタックを持つことで、以前の状態を保存して呼び出せる
状態をプッシュして、最新の状態はポップで呼び出す

```ts
const state = ["立っている"];
// ↓ push
const state = ["喋っている", "立っている"];
// ↓ pop
const state = ["立っている"];
```

## ダブルバッファ

バッファを２つ体制にすることで、レンダリングの切り替えをスムーズに行う
バッファ A を読み込んでるときに、バッファ B に書き込み、バッファ B を読み込んでるときに、バッファ A に書き込む

- 徐々に変更される状態が存在する。
- その状態は変更中に読み込まれる可能性がある。
- 状態が変更中であることを外部からアクセスするコードにはわからせたくない。
- 状態の変更中も読み込みが可能であることが必要で、変更が終了するまで待つことはできない。

## 型オブジェクト

継承を行わずに、インスタンスの型を決定するオブジェクト

「Monster」オブジェクトを継承して「竜」オブジェクトを作るような、無限にサブクラスができるようなことはしない  
「Monster」オブジェクトを継承する「系統」オブジェクトがあり、それを継承して「竜」オブジェクトを作る
ここでいう「系統」オブジェクトが型オブジェクト

## サービスロケータ

サービスの実装の具体がどこにあるのかを教えてくれる  
これによって、具体がどのように変わったとしても、クライアントは気にすることなくサービスを使うことができる

```ts
class Locator {
  constructor() {}
  static getAudio() {
    // 以前までこっちを使っていた
    // return new Audio()
    return new NewAudio();
  }
}
```

- 在り処を返されている実装は、ロケーターに依存されていることを知らない
- Locator を介してサービスにアクセスすれば、期待する動きをするサービスを使うことができる

## dirty flag

- A(親)
  - B(A に依存)
    - C(B に依存)
      - D(C に依存)
        - E(D に依存)

子は親に依存しているとする  
子の絶対的変換情報は、親という相対的変換情報に依存している  
依存関係が深いと、どこかの親が変更されたときに、それ以下の子たちの絶対的変換情報が更新される  
親が 5 つ上にあると、5+4+3+2+1 = n(n+1)/2 回更新される

```md
A を更新した場合、

1. A が更新されたので、A に依存している B が更新、B に依存している C が更新、C に依存している D が更新、D に依存している E が更新
2. B が更新されたので、B に依存している C が更新、C に依存している D が更新、D に依存している E が更新
3. C が更新されたので、C に依存している D が更新、D に依存している E が更新
4. D が更新されたので、D に依存している E が更新
```

一方で、相対的変換情報の変更と絶対的変換情報の更新を分離できれば、相対的変換情報をまとめて変換&絶対的変換情報を 1 回だけ更新すれば良くなる

```md
A を更新した場合、

1. A が更新されたので、A に依存している B が更新、B に依存している C が更新、C に依存している D が更新、D に依存している E が更新
```

これだけで良い  
親が 5 つ上にあると、1+1+1+1+1 = n 回更新される

相対的変換情報が変化したら、フラグをセットする  
絶対的変換情報の更新が必要になったらフラグをチェックし、

- フラグがある
  - 相対的変換情報が更新されたという意味になり、絶対的変換情報を更新、フラグをクリア
- フラグがない
  - 相対的変換情報が更新されていないという意味になり、絶対的変換情報を更新せず、フラグはそのまま

「絶対的変換情報が古くなっているか」を確認するフラグを dirty flag と呼ぶ  
dirty = 古くなっていること
