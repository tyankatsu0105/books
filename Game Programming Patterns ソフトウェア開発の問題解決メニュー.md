## いいデザイン

何かを変更したときに、プログラム全体がその変更を予期していたように作られている設計  
変更を容易にするもの

## プログラミングフロー

1. 問題発見
   - 機能を試して改良の余地や、不具合を発見する
2. コードの熟読
   - 今あるコードを読む
   - 何をしているのかの把握
3. 解決策のコード化
   - 解法をコードに書き起こす
   - 試行錯誤を繰り返す
   - 比較的簡単なこともある
4. 後片付け
   - テストを作成
   - 試行錯誤のために仕込んだログの削除

## よいアーキテクチャの豊漁発揮のタイミング

コードを読んで理解するとき  
分離できていない（結合している） = 一方を理解していないともう一方が理解できない  
分離ができていると変更が全体に及ぼす影響は少ない  
次に進む前に頭に入れておかなければならない知識を最小にすること

## 分離

抽象化、モジュール化、デザインパターン、ソフトウェアアーキテクチャといったものにこだわると、いい分離ができるようになる  
しかしちゃんと学ばないと、過度に複雑化していく

## ソフトウェアアーキテクチャと抽象化 vs 実行速度

開発効率のためのアーキテクチャと引き換えに、ある程度の実行コストが発生する  
しかし、開発効率を上げてアプリケーションの実装スピードを上げた文だけアプリケーションの機能開発に時間を割けられる  
開発効率を上げてアプリケーションに十分な機能を作れてきたら、実行速度を高めるためにいくつかの抽象化を取り除いていったほうが効率的

## プロトタイプを作成する時期のなぐり書きコード

プロトタイプを作成する時期は、アプリケーションが市場で通用するか検証をするタイミング  
このときにアーキテクチャを考えて整ったコードを書くのは一種の賭け  
捨てる確率が高いので、無意味なアーキテクチャになる可能性がある  
そのため、なぐり書きコードを書くことが多い
しかし、そのプロトタイプをそのまま市場に出すこともある。そのときなぐり書きコードをそのままメンテナンスしなければならなくなり、首を締めることに成る

## 3 つの目標のトレードオフ

- プロジェクトが生きている間はコードが読みやすくなければならないので、整ったアーキテクチャが維持される。
- 実行速度が速い。
- 今日見い出された問題にできるだけ短期間で答えを出せる。

機能開発は 3 つの目標のトレードオフの繰り返し  
プロジェクトで最適な距離感を見つけることが重要

## コマンド

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#command
undo redo のように状態が必要になるときがあるが、JS のようにクロージャーがあれば、クラス以外に関数でもかける。

## フライウェイト

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#flyweight
最低限共通化してもいいモデルを一個生成して、それを複数のインスタンス化する際に流用する  
オブジェクトの軽量化を担う

- intrinsic
  - すべてのインスタンスで共有できるモデル
- extrinsic
  - インスタンス固有のもの

の２つで構成

## オブザーバー

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#observer

特定のイベントを発生するサブジェクトが、リスト登録されたオブジェクト（オブザーバ）に変更を通知する  
それぞれのオブザーバは独立しているので、１つのイベントで複数のオブザーバに通知することができる  
サブジェクトはオブザーバに「通知する」役割があるので、そのタイミングで各オブザーバが処理を実行できる  
サブジェクトとオブザーバは密に結合していないが間接的につながっているので結合度を下げることができる

オブザーバには意見がある

### 処理速度がおそすぎる

「キューイング」や「動的確保」といった意図的に遅くしているものがある

## プロトタイプ

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#prototype

JSON のように、共通のプロパティを含むが、一部違うようなオブジェクトを定義するなら、基底クラスを作って、それを継承するかミックスインとして使うとコード量が減る

## シングルトン

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#singleton

クラスにカプセル化したグローバル変数なので、使わないほうがいい  
アクセス性が良くなるだけだが、メリットはそれ以外ない

## ステート

https://github.com/tyankatsu0105/design-patterns/tree/main/TypeScript/GOF#state

### FSM 有限状態機械

計算機科学のオートマトン理論分野から生まれた「状態」と「遷移」の概念を用いたモデル

- 可能な状態の集合がある
  - 食べる、飲む、寝る、起きる
- 一度に１つの状態になる
  - 食べる状態になると、飲む状態にはなれない
- 一連のイベント、入力が与えられる
- とある状態で一連の入力があれば、決まった状態へ遷移する
  - 「寝る」状態で「8 時間経過」というイベントで「起きる」状態へ遷移する

状態機械は、扱いにくい問題に対して非常に制限的な構造を強制することでわかりやすくするのを助ける一方で、複雑なことをやるには扱いにくい

### 並行状態機械

X しながら Y するというように、２つの状態を持ちたいとき、１つの状態機械では表現できない  
そこで２つの状態機械を並行させることで表現する

### 階層的状態機械

よくわからん

### プッシュダウンオートマトン

状態のスタックを持つことで、以前の状態を保存して呼び出せる
状態をプッシュして、最新の状態はポップで呼び出す

```ts
const state = ["立っている"];
// ↓ push
const state = ["喋っている", "立っている"];
// ↓ pop
const state = ["立っている"];
```

## ダブルバッファ

バッファを２つ体制にすることで、レンダリングの切り替えをスムーズに行う
バッファ A を読み込んでるときに、バッファ B に書き込み、バッファ B を読み込んでるときに、バッファ A に書き込む

- 徐々に変更される状態が存在する。
- その状態は変更中に読み込まれる可能性がある。
- 状態が変更中であることを外部からアクセスするコードにはわからせたくない。
- 状態の変更中も読み込みが可能であることが必要で、変更が終了するまで待つことはできない。
