# 1 章 ウェブパフォーマンスとは何か

- インタラクション = ユーザーの行動によってウェブページが何かしらの応答をする行為
- 複雑なインタラクションを持つアプリケーションが今多い
  - ウェブで表現できることが増えたから
- 今までは画面の初期表示スピードさえ気にしていればよかった
- SPA みたいに、初期ロード + インタラクションの描画パフォーマンスが重要になってきた
- ハイブリッドアプリ = HTML,CSS,JS で開発可能な OS ネイティブアプリケーションみたいに利用できるアプリケーション
- ネイティブアプリはコードがコンパイル済み + OS が API を直接用いるから高速
- ハイブリッドアプリはレンダリングエンジンに JS を解釈される必要があるし、HTML と CSS を解釈して描画するため描画パフォーマンス低い

# 2 章 ブラウザのレンダリングの仕組み

- ブラウザを構成する複数のコンポーネントのうちの重要な２つ
  - レンダリングエンジン
    - HTML の描画エンジン
    - HTML、画像、CSS、JS などのリソースをもとに画面上にピクセルで描画
    - Blink、Webkit など
    - ブラウザ以外でも HTML メールの表示に使われていたりする
    - ハイブリッドエンジンはレンダリングエンジンを組み込んでいる
  - JavaScript エンジン
    - JS の実行環境
    - V8、Chakra など
    - DOM ツリー構築、CSSOM ツリー構築、ブラウザ API への JS からのアクセスするバインディング
    - JS エンジンはブラウザ以外にも Node.js に V8 が使われていたり、単独の言語処理系として使われる
- レンダリングの流れ
  - 大きく 4 つ（総称をフレーム）
    - Loading => Scripting => Rendering => Painting
  - 細かくできる
    - Download(Loading) => Parse(Loading) => Scripting => Calculate Style(Rendering) => Layout(Rendering) => Paint(Painting) => Rasterize(Painting) => Composite Layouts(Painting)
  - https://web.dev/rendering-performance/ のピクセルパイプライン

## Loading

- サーバーからリソースのダウンロード
  - HTML ファイル
  - CSS ファイル
  - JS ファイル
  - 画像ファイル
- リソースのパース
  - このときに HTML は DOM ツリー、CSS は CSSOM ツリーへ変換される
- リソース取得順序
  - HTML が最初
    - HTML 内で参照しているリソースがあれば、そのリソースをロードする
    - 取得されたリソースはレンダリングエンジンの実装に沿った内部表現へ変換される
      - HTML は DOM ツリーへ
      - CSS は CSSOM ツリーへ
    - DOM ツリーを構築していく過程で、画像や CSS などのリソースを取得する
    - DOM ツリー構築の流れ
      - 字句解析によるトークンのリスト化
      - 構文解析による構文木の構築
      - 構文木内にある JS を実行しつつ DOM ツリーの構築
  - CSS が同時進行
    - 読み込まれた CSS をもとに CSSOM ツリー構築
    - ルールセットが増えると DOM ツリーのノードに適用されるスタイル計算の時間がかかる

## Scripting

- JS 実行の流れ
  - JS コード => 字句解析（トークン列生成） => 構文解析（AST 生成） => コンパイル（実行可能コード生成） => 実行
- コンパイル
  - 仮想マシンコードへのコンパイル
    - 言語処理を実行できる仮想マシンを用意し、それに向けてコンパイルする
      - 別名　バイトコードインタープリター
      - JIT コンパイル型よりも実装かんたん
      - 仮想マシンを使うので、マルチプラットフォーム対応がかんたん
    - JIT コンパイル
      - マシンの CPU が処理できるコードにコンパイルする
      - 機械語への変換により、実行時のパフォーマンス高い
      - マルチプラットフォーム対応が難しい
        - 実行環境の CPU によってコンパイルを分けないといけないから
- コンパイルが終わると実行し、DOM API の操作で DOM ツリーの操作が可能になる

## Rendering

- Calculate Style
  - DOM ツリーの全 DOM の CSS プロパティが何か計算
    - CSSOM ツリー内の CSS ルールセット（セレクタ＋ルール）を全部見る
    - DOM にどのルールが適用されるか計算
      - セレクタのマッチング処理
        - 右側からマッチング処理が適用
          - button .button
          - button クラスの button element
    - css の詳細度決定
    - 詳細度によって、該当 DOM の CSS ルールの適用を確定
- Layout
  - 要素の「大きさ」「マージン」「パディング」「位置」「z 軸の位置」などのレイアウト情報を計算
- Painting

## Painting

- Paint
  - 2D グラフィックエンジン向けの命令の列を生成する
    - レンダリングエンジンでは、グラフィックエンジンを組み込めるようになっている
    - Skia というグラフィックエンジンが主流
- Rasterize
  - Paint での命令をもとにピクセルへと描画
    - レイヤーに一枚一枚描画
      - レイヤーは Z 軸での上下関係を持つ
      - オーバーラップして表示されるコンテンツが有る場合に生成
        - position: absolute
        - position: fixed
        - transform: translate3d などの GPU で描画合成する
        - opacity を使って背後の何かを表示する必要がある
    - レイヤーを再利用することで、再レンダリングのスピードが上がる
      - スクロールするときは以前描画したレイヤーが再利用される
- Composite Layers
  - レイヤーを合成して最終的なレンダリング結果を生成
    - レイヤーは CPU と GPU で生成される
  - 基本的に CPU で条件満たすと GPU 合成

### 再レンダリング

- 何が変更されたかによってどのフェーズから再実行されるのか決まる

# 3 章 チューニングの基礎

- パフォーマンスの指標

  - RAIL
    - response 100 ミリ秒
      - アクションを起こしてなにかしらのフィードバックを返すまでのタイム
      - 指のタッチ、スクロールなどは 16 ミリ秒以下
        - これらのアクションは 100 ミリ秒以下の高い頻度でおこるため
    - animation 16 ミリ秒
      - 16 ミリ秒だと 60fps が実現できる
        - 1000 / 60 = 16.6666666667
      - アニメーションを実現するために JS を使う場合は、その JS 処理時間は 6 ミリ秒以下
        - システムや OS や GPU ドライバや描画合成の固定的な処理時間などに 4 ミリ秒
        - つまり、16 - 4 = 12
        - 安定的に 60fps を実現するためには JS 処理時間は半分の 12 / 2 = 6 ミリ秒以下が望ましい
      - CSS だと JS が必要ないので、1 フレーム（Scripting, Rendering, Painting）16 ミリ秒以下でいい
    - idle 50 ミリ秒
      - アイドル状態に実行される JS の処理時間
        - 一度 Painting まで終わって、ユーザからのアクションを待ち受けている状態
    - load 1000 ミリ秒
      - ページ読み込み開始からユーザがそのページを操作できるまでの時間

- 残りは計測方法に関しての説明

# 4 章 リソース読み込みのチューニング

- 最初に取得した html が参照しているソースを取得していく
  - `<link>`の css ファイル
    - css ファイルが参照している css ファイル
  - `<script>`の js ファイル
  - src の画像ファイル

## ファイルの圧縮

不要な空白なくしたり、変数名短くしたり

## 適切な画像形式

- jpeg
  - 画像
- gif
  - アニメーション
- png
  - それ以外
- webp
  - 2022/0620 現在 safari だけ特定条件だと使えない

## フォントの最適化

- フォントを使う場合、当然 loading される
- 日本語フォントはでかい
- サブセット化
  - ページ中で使うフォントだけ抜き出して配信する方法

## css import を避ける

- `@import`構文は import を書いた css ファイルが読み込まれるのを待ってから、その import 先 css ファイルを取得する
- つまり直列
- css ファイルの結合は良い手段
  - webpack https://webpack.js.org/plugins/css-minimizer-webpack-plugin/
  - vite https://vitejs.dev/guide/features.html#import-inlining-and-rebasing

## JS の同期読み込みを避ける

- DOM ツリー構築中に DOM を変更するような処理を書かない
  - `document.write("<div>hello</div>")`
  - html のパースを阻害する
- 同期的な処理を行う場合は html の最後の方に書く
  - link タグの読み込みの阻害をさせない

## JS を非同期で読み込む

- defer と async 属性
  - defer
    - 非同期で読み込む
    - ドキュメントのパースをロックしない
    - DOM ツリー構築後に実行
    - 宣言順は担保される
      - `<script defer src="1.js"></script> <script defer src="2.js"></script>`で 1.js => 2.js の順に実行される
    - DOMContentLoaded イベントの発火前に実行される
  - async
    - defer と同じ
    - DOM ツリー構築を待たず、js を読み込んだと同時に実行される
    - 実行順は担保されない
      - `<script async src="1.js"></script> <script async src="2.js"></script>`でも、どっちが最初に実行されるかわからない
- JS から`<script>`を生成して DOM に追加

  - defer async をサポートしていない場合にこの手法を使う
  - 基本的に defer async でいい

- 使う優先順位
  - async,defer,script element
  - async が一番パフォーマンスがいい

## ピクセル比で読み込む画像を変える

- img の srcset を使って、無意味に高画質な画像を読み込ませないように抑えることができる
- picture の source で画面幅による画像の使い分けができる

## css メディアクエリを適切に指定

- 画面に必要ないスタイルはメディアクエリで読み込ませない
  - link 要素の media 属性を指定すると、まるごと css ファイルを読ませないことができる
  - css 内でのメディアクエリではなく、media 属性を使うと効果的

## css スプライト

- HTTP/1.1 以下では 1 リソース 1 リクエストになる
- HTTP リクエストの並列数はブラウザ側で制限があるので、そこを圧迫しないように、複数の画像を１つの画像にまとめてしまう。
  - 接続ブロックを防ぐ
  - HTTP リクエストヘッダーと HTTP レスポンスヘッダーは通常 700~800 バイトであり、「画像数 \* 800 バイト前後」になっていたのを、「800 バイト前後」だけで済ませられる

## クリティカル CSS

- クリティカルレンダリングパス
  - ウェブページの初回の描画に必ず必要な工程
- link 要素の css ファイルの読み込みは初回の描画をブロックする
- CSS をインライン化させて任意のスタイルを読み込ませる = クリティカル CSS
  - css ファイルの読み込みをスキップさせて、CSS ファイルの初回描画を邪魔させない
    - `<link rel="stylesheet" href="style.css" media="none" onload="if (media !== 'all') {media = 'all';}">`
      - `media="none"`といった属性値は存在しないので、ブラウザは読み込みをスキップして描画を始める
      - やがて load されたあとに、media を all にして、ちゃんと使われるようにする
    - style タグにウィンドウに表示する領域のスタイルを直書きする

# 5 章 JavaScript 実行のチューニング

# 6 章 レイアウトツリー構築のチューニング

# 7 章 レンダリング結果の描画のチューニング

# 8 章 高度なチューニング

# 9 章 認知的チューニング
