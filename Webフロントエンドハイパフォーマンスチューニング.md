# 1 章 ウェブパフォーマンスとは何か

- インタラクション = ユーザーの行動によってウェブページが何かしらの応答をする行為
- 複雑なインタラクションを持つアプリケーションが今多い
  - ウェブで表現できることが増えたから
- 今までは画面の初期表示スピードさえ気にしていればよかった
- SPA みたいに、初期ロード + インタラクションの描画パフォーマンスが重要になってきた
- ハイブリッドアプリ = HTML,CSS,JS で開発可能な OS ネイティブアプリケーションみたいに利用できるアプリケーション
- ネイティブアプリはコードがコンパイル済み + OS が API を直接用いるから高速
- ハイブリッドアプリはレンダリングエンジンに JS を解釈される必要があるし、HTML と CSS を解釈して描画するため描画パフォーマンス低い

# 2 章 ブラウザのレンダリングの仕組み

- ブラウザを構成する複数のコンポーネントのうちの重要な２つ
  - レンダリングエンジン
    - HTML の描画エンジン
    - HTML、画像、CSS、JS などのリソースをもとに画面上にピクセルで描画
    - Blink、Webkit など
    - ブラウザ以外でも HTML メールの表示に使われていたりする
    - ハイブリッドエンジンはレンダリングエンジンを組み込んでいる
  - JavaScript エンジン
    - JS の実行環境
    - V8、Chakra など
    - DOM ツリー構築、CSSOM ツリー構築、ブラウザ API への JS からのアクセスするバインディング
    - JS エンジンはブラウザ以外にも Node.js に V8 が使われていたり、単独の言語処理系として使われる
- レンダリングの流れ
  - 大きく 4 つ（総称をフレーム）
    - Loading => Scripting => Rendering => Painting
  - 細かくできる
    - Download(Loading) => Parse(Loading) => Scripting => Calculate Style(Rendering) => Layout(Rendering) => Paint(Painting) => Rasterize(Painting) => Composite Layouts(Painting)
  - https://web.dev/rendering-performance/ のピクセルパイプライン

## Loading

- サーバーからリソースのダウンロード
  - HTML ファイル
  - CSS ファイル
  - JS ファイル
  - 画像ファイル
- リソースのパース
  - このときに HTML は DOM ツリー、CSS は CSSOM ツリーへ変換される
- リソース取得順序
  - HTML が最初
    - HTML 内で参照しているリソースがあれば、そのリソースをロードする
    - 取得されたリソースはレンダリングエンジンの実装に沿った内部表現へ変換される
      - HTML は DOM ツリーへ
      - CSS は CSSOM ツリーへ
    - DOM ツリーを構築していく過程で、画像や CSS などのリソースを取得する
    - DOM ツリー構築の流れ
      - 字句解析によるトークンのリスト化
      - 構文解析による構文木の構築
      - 構文木内にある JS を実行しつつ DOM ツリーの構築
  - CSS が同時進行
    - 読み込まれた CSS をもとに CSSOM ツリー構築
    - ルールセットが増えると DOM ツリーのノードに適用されるスタイル計算の時間がかかる

## Scripting

- JS 実行の流れ
  - JS コード => 字句解析（トークン列生成） => 構文解析（AST 生成） => コンパイル（実行可能コード生成） => 実行
- コンパイル
  - 仮想マシンコードへのコンパイル
    - 言語処理を実行できる仮想マシンを用意し、それに向けてコンパイルする
      - 別名　バイトコードインタープリター
      - JIT コンパイル型よりも実装かんたん
      - 仮想マシンを使うので、マルチプラットフォーム対応がかんたん
    - JIT コンパイル
      - マシンの CPU が処理できるコードにコンパイルする
      - 機械語への変換により、実行時のパフォーマンス高い
      - マルチプラットフォーム対応が難しい
        - 実行環境の CPU によってコンパイルを分けないといけないから
- コンパイルが終わると実行し、DOM API の操作で DOM ツリーの操作が可能になる

## Rendering

- Calculate Style
  - DOM ツリーの全 DOM の CSS プロパティが何か計算
    - CSSOM ツリー内の CSS ルールセット（セレクタ＋ルール）を全部見る
    - DOM にどのルールが適用されるか計算
      - セレクタのマッチング処理
        - 右側からマッチング処理が適用
          - button .button
          - button クラスの button element
    - css の詳細度決定
    - 詳細度によって、該当 DOM の CSS ルールの適用を確定
- Layout
  - 要素の「大きさ」「マージン」「パディング」「位置」「z 軸の位置」などのレイアウト情報を計算
- Painting

## Painting

- Paint
  - 2D グラフィックエンジン向けの命令の列を生成する
    - レンダリングエンジンでは、グラフィックエンジンを組み込めるようになっている
    - Skia というグラフィックエンジンが主流
- Rasterize
  - Paint での命令をもとにピクセルへと描画
    - レイヤーに一枚一枚描画
      - レイヤーは Z 軸での上下関係を持つ
      - オーバーラップして表示されるコンテンツが有る場合に生成
        - position: absolute
        - position: fixed
        - transform: translate3d などの GPU で描画合成する
        - opacity を使って背後の何かを表示する必要がある
    - レイヤーを再利用することで、再レンダリングのスピードが上がる
      - スクロールするときは以前描画したレイヤーが再利用される
- Composite Layers
  - レイヤーを合成して最終的なレンダリング結果を生成
    - レイヤーは CPU と GPU で生成される
  - 基本的に CPU で条件満たすと GPU 合成

### 再レンダリング

- 何が変更されたかによってどのフェーズから再実行されるのか決まる

# 3 章 チューニングの基礎

# 4 章 リソース読み込みのチューニング

# 5 章 JavaScript 実行のチューニング

# 6 章 レイアウトツリー構築のチューニング

# 7 章 レンダリング結果の描画のチューニング

# 8 章 高度なチューニング

# 9 章 認知的チューニング
